---
title: 算法-几种排序算法的实现
tags: 算法
---

## 快速排序（快拍）
快速排序的思想是分治，时间复杂度O(nlogn)，当然快速排序的时间复杂度并不是稳定的，最大时间复杂度是n^2。当然在用C语言实现的快速排序中，快速排序是原地排序，所有空间复杂更低。

## 并归排序
基于链表的并归排序。
并归排序的思想是分治的思想，时间复杂度 O(nlogn)。
- 如果一个链表（数组）只有一个元素或者为空直接返回。
- 如果链表（数组）可以分成尽可能相等两部分，将其分成尽可能相等两部分。
- 对于两个被分开的两个部分进行整个归并排序
- 把两个拍好序的链表（数组）进行合并。
与快拍的区别是：`快拍是先处理完再递归` 而归并排序是`先递归在处理`
`链表的归并排序`

```c
 struct ListNode * merge(struct ListNode *l1,struct ListNode *l2)
 {
     if(l1 == NULL) return l2;
     if(l2 == NULL) return l1;
     if( (l1==NULL) &&(l2==NULL) ) return NULL;
     
     struct ListNode *head=NULL;
     if(l1->val < l2->val)
    {
        head=l1;
        l1=l1->next;
    }
     else 
     {
         head=l2;
         l2=l2->next;
     }
     
     struct ListNode *p=head;
     while(l1 != NULL && l2 != NULL)
     {
         if(l1->val < l2->val)
         {
             p->next=l1;
             l1=l1->next;
         }
         else
         {
             p->next=l2;
             l2=l2->next;
         }
         p=p->next;
     }
     
     if(l1 != NULL) p->next=l1;
     if(l2 != NULL) p->next=l2;
     return head;
 }
 
struct ListNode* sortList(struct ListNode* head) {
    if(head == NULL || head->next == NULL) return head;
    struct ListNode *slow=head;
    struct ListNode *fast=head;
    struct ListNode *pre=NULL;
    
    // 切成两半
    while(fast!= NULL && fast->next != NULL)
    {
        pre=slow;
        slow=slow->next;
        fast=fast->next->next;
    }
    pre->next=NULL;
    
    //两半分别归并
    struct ListNode *l1=sortList(head);
    struct ListNode *l2=sortList(slow);
    
    //调用merge
    return merge(l1,l2);
}
```


