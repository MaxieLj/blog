---
title: 数据库隔离级别
date: 2018-04-23 20:34:25
tags: 数据库
toc: true
categories: 数据库
---

SQL标准规范中定义了四种数据库隔离级别。每种隔离级别带来的系统开销是不一样的。通常较低的隔离级别的系统开销会更低，可以执行更高的并发。

## READ COMMITTED(未提交读)
顾名思义，未提交读隔离级别中，事物的修改即使没有提交，对其他事务也是可见的。事务可以读取为未提交的数据，也成为`脏读`。READ COMMITED 性能上不会有跟很大的优势，但是却会导致很多的问题，在实际应用中很少使用。

eg:
业务场景支付扣款。当用户统一时刻发生一笔充值500，和一笔扣款200业务时。 扣款读到是未执行的充值事务金额，账户余额500元，但是充值事务回滚了，这种情况下数据出现问题，所以未提交读是一种不可靠的事务。


## READ COMMITED(提交读)
多数数据库的隔离级是提交读(比如Sql Server , Oracle)，但是mysql不是。
提交读的含义是：一个事务只能看到已经提交的事务所做的修改。也就是说事务和事务之前在提交前是相互不可见的。这个级别又称为不可重复读，因为每次读取的结果可能是不一样的。

eg:
当我们拿着银行卡去消费时候，查询到卡里还有2000元，这时准备消费。与此同时这张卡的钱被老婆转账了（已经转出去2000元），当我们在扣款你的时候会提示余额不足。
提交读避免了`脏读`，但是却产生了`不可重复读`（同一事务内）。

## Repeatable read （重复读）

重复读，保证了在同一个事务内读取同一条数据是不变的，但是却无法保证我们读取（同一事务内）同一表里的数据量是一致的。但是却会产生幻读（幻行）。

例如消费记录表，我们在打印信用卡的消费记录时查询出来只有一条消费记录80（这是另外一个事务无法改变的），但是在我们打印的时候，老婆又消费了1000元（另外一个事务，但是没有对原来的80元进行修改），我们打印出来的结果是两条记录 80 +1000，这就是幻行。



## Serializable （序列化）
Serializable 通过强制事务串行执行避免了欢读。但是Serializable在执行的时候会对每一样的数据都加上锁，会导致大量的超时和锁竞争。只有在数据一致性非常重要，且并发不是很大情况选，可以选用这种隔离级别。


## 几个名词

### 脏读
指的是在A事务内，多次读取同一一个数据。与此同时还有另外一个B事务对同一数据进行了修改，但是未提交。这时就会产生事务A两次读取的数据不一致，一个是事务B未执行前的数据，一个是读取事务B未提交的数据。

### 不可重复读。
指的是同一事务内，无法对同一个数据多次读取，因为两次读取可能是不一致的（因为没有对 数据写 加锁）。

### 幻读

幻读是在`可重复读`的隔离级别下产生的问题。`可重复读`虽然对数据加写锁，但是却没对表加锁，造成每次读取表的数据量是不一致的，所以又称`幻行`。
