---
title: 浅谈MySql的MVVC
date: 2020-03-13 14:01:50
tags:
categories: 数据库
toc: true
---

## 摘要
MySQL的大多数事务性存储引擎实现都不是建单的行级锁。基于提升并发性能的考虑，他们一般都是同事实现了多版本并发控制。

可以认为MVVC是行级锁的一种变种，但是它在很多情况下避免了加锁操作，隐藏开销更低。虽然实现机制不同，但大家都实现了非阻塞的读操作，写操作也只锁定必要的行。

MVVC的实现，是通过八寸数据在某个时间节点的快照来实现的。

innoDB的MVVC,是通过在每行记录后保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存了行的过期时间（删除时间）。当然存储的并非是是实际的时间值，而是系统的版本号。每开始一个事务，系统版本号都会自动递增。事物的开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较，下面看一下在REPEATABLE READ隔离界别下，MVVC具体是如何操作的。


```
SELECT 
    InnoDB会根据一下两个条件检查每行记录：
    a.InnoDB只查找版本遭遇当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。
    b.行的删除版本要么未定义，要么大于当前事务的版本号。这可以确保事务读到的行，在事务开始前未被删除。

INSERT
    InnoDB为新插入的每一行保存当前系统版本号作为行版本号。

DELETE
    InnoDB为删除的每一行保存当前系统版本号作为行删除标识。

UPDATEI
    InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同事保存当前系统版本号到原来的行作为行删除标识。    
```

保存这两个额外系统版本号，使多数读操作都可以不用加锁。这样设计是的读数据操作很简单，性能很好。并且也能保证只会读取到符合标准的行。不足之外是每行记录都需要额外的空间，需要做更多的行检查工作，以及一些额外的维护工作。

MVVC只在REPEATABLE READ和READ COMMITTED两个隔离界别下工作。其他两个隔离级别都和MVVC不兼容，因为READ UNCOMMITTED总是读取最新的数据行，而不是符合当前事务版本的数据行。二SERIALIZABLE则会对所有读取的行都加锁。