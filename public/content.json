[{"title":"我不是药神","date":"2018-07-13T14:44:43.000Z","path":"2018/07/13/我不是药神/","text":"一直以来都想成为一个坚强的人,但是生活中还是有很多时候让我情不自禁,一部电影被感动哭的稀里哗啦,不得不承认我是个泪点很低的人,但是我想这并不妨碍我成为一个坚强的人。 看完点影,不禁想问自己几个问题: 电影里徐峥错了么?好像并没有什么大错。尊重知识产权确实一个严肃的问题,不然社会没有前进的动力。 警察错了么? 好像也没有错,秉公执法的警察才是好警察。 病人错了么? 明明知道这是走私药,却仍然要买,我想对于想要活命的人来说,什么都无足轻重了。只有哪些真正历过生离死别,一直在生与死的边缘挣扎的人, 才知道生命的可贵。 到底是哪里错了? 我想真的事像电影里所说的一样, 都是因为穷。如果穷是原罪的话,我想这个世界大多数人都犯了很重的罪。那么错在哪里, 我想我们的国家体制已经意识到了,她在改变。 黄毛是个仗义的兄弟, 看到了黄毛, 这不禁让我想到我的高中, 想到了当我处于和别人争执的时候那些为我站出来的朋友。 我想我一直是一个不善于表达的人, 无论对于父母, 伴侣, 还是朋友, 对于他们我一直都很吝啬赞美之词。 最后一个问题, 如果我是徐峥, 我会站出来么? 当我事业有成的时候, 衣食无忧的时候, 家庭美满的时候, 我会为那些需要帮助的人站出来么? 但是我知道, 那些站出来的背影真的很帅, 也值得我们尊敬。","tags":[]},{"title":"微服务数据一致性和服务可靠性","date":"2018-07-12T13:54:30.353Z","path":"2018/07/12/微服务数据一致性和服务可靠性/","text":"存在问题 我们的保证金服务现有结构是这个样子。在 1、2、3、4、5、6 各个阶段都会存在超时和异常问题，当负载少时，我们还可以手动人工处理，但是当数据量大的时候，问题或多的令人发指，沉浸于洗数据，无法自拔。。超时存在问题：1.当1、2、3 步骤超时时，下游服务可以忽略，当做执行失败，重试。2.当在环节4、5、6超时时，对于下游服务是也是执行失败，但是还可以重试么？ 如何提高服务可靠性对于上游服务，如何保证对下游提供可靠的服务。 补偿机制 在服务间的调用失败时，可以记录失败调用，如队列，消费重试。但是前提一定是接口幂等。 但是这样并不能解决根本性问题，如果我们在调用保证金冻结服务时，失败此时我们冻结时报操作入队列，让队列异步消费，如果此时要解冻保证金，就会出现业务异常。 所以补偿机制建议使用在 不可避免的业务异常情况下使用，我们应该尽可能的优化技术方案，来保证数据一致性，最后再采用补偿机制。 两段提交协议（2pc） preOperation 执行请求，在调用微服务前，执行预操作成功则表示此次操作可行。如果commit失败该如何处理？重新preOperetion嘛？如果接口幂等是否可以重复，commit？如何保证避免重复提交？在preOperation时，返回唯一操作ID，业务逻辑每个操作对应一个操作ID，commit失败就重试，当然前提是我们的上有服务接口幂等。 即使是这样也会存在问题，如果保证金预操作成功，但是执行一直失败呢？我们必须提供回滚机制。 大量同步RPC依赖，如何保证自身服务可靠性？ 服务之间在调用的时候，会存在大量异常、超时。我该如何处理，认为这次是失败的？还是成功的？如果依赖的服务返回成功，才算成功的话，我改如何保证服务可靠性，该如何对我的下游服务提供可靠的服务。 调用依赖服务失败，如何降级处理？ 在服务调用失败的时候，我的上游出错了，我该如何降级处理，我该重试？还是直接跳过，跳过后是否会造成微服务之间数据一致性问题。如果重试是否会造成重复提交，接口是否幂等？ 是否还欠缺回滚机制？","tags":[{"name":"分布式,事务","slug":"分布式-事务","permalink":"http://yoursite.com/tags/分布式-事务/"}]},{"title":"Item2使用sz rz命令从服务下载上传文件","date":"2018-07-12T13:27:37.000Z","path":"2018/07/12/使用sz-rz命令从服务下载上传文件/","text":"背景如何从linux服务下载/上传文件 使用scp命令 使用sz命令 这里主要介绍使用sz命令下载文件 安装 安装lrzsz hobrew install llssz 在本地编写shell用于接受sz命令下载下来的文件 上传shell iterm2-send-zmodem.sh12345678910111213141516171819202122232425262728293031323334#!/bin/bash#Author: Matt Mastracci (matthew@mastracci.com)# AppleScript from http://stackoverflow.com/questions/4309087/cancel-button-on-osascript-in-a-bash-script# licensed under cc-wiki with attribution required# Remainder of script public domainosascript -e &apos;tell application &quot;iTerm2&quot; to version&apos; &gt; /dev/null 2&gt;&amp;1 &amp;&amp; NAME=iTerm2 || NAME=iTermif [[ $NAME = &quot;iTerm&quot; ]]; then FILE=`osascript -e &apos;tell application &quot;iTerm&quot; to activate&apos; -e &apos;tell application &quot;iTerm&quot; to set thefile to choose file with prompt &quot;Choose a file to send&quot;&apos; -e &quot;do shell script (\\&quot;echo \\&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\\&quot;\\&quot;)&quot;`else FILE=`osascript -e &apos;tell application &quot;iTerm2&quot; to activate&apos; -e &apos;tell application &quot;iTerm2&quot; to set thefile to choose file with prompt &quot;Choose a file to send&quot;&apos; -e &quot;do shell script (\\&quot;echo \\&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\\&quot;\\&quot;)&quot;`fiif [[ $FILE = &quot;&quot; ]]; then echo Cancelled. # Send ZModem cancel echo -e \\\\x18\\\\x18\\\\x18\\\\x18\\\\x18 sleep 1 echo echo \\# Cancelled transferelse /usr/local/bin/sz &quot;$FILE&quot; -e -b sleep 1 echo echo \\# Received $FILEfi 下载shell iterm2-recv-zmodem.sh 12345678910111213141516171819202122232425262728#!/bin/bash# Author: Matt Mastracci (matthew@mastracci.com)# AppleScript from http://stackoverflow.com/questions/4309087/cancel-button-on-osascript-in-a-bash-script# licensed under cc-wiki with attribution required # Remainder of script public domainosascript -e &apos;tell application &quot;iTerm2&quot; to version&apos; &gt; /dev/null 2&gt;&amp;1 &amp;&amp; NAME=iTerm2 || NAME=iTermif [[ $NAME = &quot;iTerm&quot; ]]; then FILE=`osascript -e &apos;tell application &quot;iTerm&quot; to activate&apos; -e &apos;tell application &quot;iTerm&quot; to set thefile to choose folder with prompt &quot;Choose a folder to place received files in&quot;&apos; -e &quot;do shell script (\\&quot;echo \\&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\\&quot;\\&quot;)&quot;`else FILE=`osascript -e &apos;tell application &quot;iTerm2&quot; to activate&apos; -e &apos;tell application &quot;iTerm2&quot; to set thefile to choose folder with prompt &quot;Choose a folder to place received files in&quot;&apos; -e &quot;do shell script (\\&quot;echo \\&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\\&quot;\\&quot;)&quot;`fiif [[ $FILE = &quot;&quot; ]]; then echo Cancelled. # Send ZModem cancel echo -e \\\\x18\\\\x18\\\\x18\\\\x18\\\\x18 sleep 1 echo echo \\# Cancelled transferelse cd &quot;$FILE&quot; /usr/local/bin/rz -E -e -b sleep 1 echo echo echo \\# Sent \\-\\&gt; $FILEfi 配置iterm2 设置Iterm2的Tirgger特性，profiles-default-editProfiles-Advanced中的Tirgger 1234567891011添加两条trigger，分别设置Regular expression，Action，Parameters，Instant如下： 1.第一条 Regular expression: rz waiting to receive.\\*\\*B0100 Action: Run Silent Coprocess Parameters: /usr/local/bin/iterm2-send-zmodem.sh Instant: checked 2.第二条 Regular expression: \\*\\*B00000000000000 Action: Run Silent Coprocess Parameters: /usr/local/bin/iterm2-recv-zmodem.sh Instant: checked 备注:注意两个文件的权限","tags":[]},{"title":"python学习笔记一","date":"2018-07-06T09:43:01.000Z","path":"2018/07/06/python学习笔记一/","text":"在php里数组分为索引数组和关联数组但sss是在python里这两者数组确实不同的数据类型list:data = [1,2,3,4,5]字典{data:1}","tags":[]},{"title":"solr-从控制页面删除数据","date":"2018-06-21T12:21:18.000Z","path":"2018/06/21/solr-从控制页面删除数据/","text":"1.xml 12&lt;delete&gt;&lt;query&gt;*:*&lt;/query&gt;&lt;/delete&gt;&lt;commit/&gt;","tags":[]},{"title":"websocket订阅火币成交记录","date":"2018-06-19T10:15:57.000Z","path":"2018/06/19/websocket订阅火币成交记录/","text":"python3单线程：文件一：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# -*- coding: utf-8 -*-#author: maxie_ljimport _threadfrom websocket import create_connectionfrom mysqlOpertion import connect_mysqlimport gzipimport timeimport json# 链接def connect(): while(1): try: print('') # 挂代理 ws = create_connection(\"wss://www.huobi.br.com/-/s/pro/ws\") #print('链接成功') return ws break except Exception as err: #print(err) #print('connect ws error,retry...') time.sleep(1)def getsubconfig(): # 统计参数 tradeStr=[ \"\"\"&#123;\"sub\": \"market.elfusdt.trade.detail\",\"id\": \"id1\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.btcusdt.trade.detail\",\"id\": \"id2\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.htusdt.trade.detail\",\"id\": \"id3\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.swftcbtc.trade.detail\",\"id\": \"id4\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.topcbtc.trade.detail\",\"id\": \"id6\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.bchusdt.trade.detail\",\"id\": \"id7\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.ethusdt.trade.detail\",\"id\": \"id8\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.etcusdt.trade.detail\",\"id\": \"id9\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.eosusdt.trade.detail\",\"id\": \"id9\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.ltcusdt.trade.detail\",\"id\": \"id9\"&#125;\"\"\" ] return tradeStr# 订阅def sub(ws,tradeStr): ws.send(tradeStr)# 获取返回def getResponse(ws,tradeStr): db = connect_mysql.connect() while 1 : try : compressData=ws.recv() except Exception : #print('链接异常') run(tradeStr,1) try : result=gzip.decompress(compressData).decode('utf-8') except: #print('丢包解析异常') continue if result[:7] == '&#123;\"ping\"': ts=result[8:21] #print('心跳包',ts) pong='&#123;\"pong\":'+ts+'&#125;' ws.send(pong) else: if result[:5] == '&#123;\"ch\"': result = json.loads(result) #print(result) #print('------------------------------------------------------') n = 0 while n &lt; len(result['tick']['data']) : connect_mysql.commit('%s' % result['ch'].split('.')[1],result['tick']['data'][n]['price'],result['tick']['data'][n]['amount'],\"'%s'\" % result[\"tick\"][\"data\"][n][\"direction\"], \"'%s'\" % result['ch'].split('.')[1],db); n += 1def subCoin(tradeStr): ws=connect() sub(ws,tradeStr) getResponse(ws,tradeStr)def run(tradeStr,test): subCoin(tradeStr)def main(): tradeStr=getsubconfig() try : tradeStr = getsubconfig() i = 0 while i &lt; len(tradeStr) : _thread.start_new_thread( run, (tradeStr[i],i) ) i += 1 except Exception as err : print(err) while 1: passif __name__ == '__main__': main() 多线程版本：文件一：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889# -*- coding: utf-8 -*-#author: maxie_ljimport _threadfrom websocket import create_connectionfrom test1 import connect_mysqlimport gzipimport timeimport json# 链接数据库def connect(): while(1): try: ws = create_connection(\"wss://www.huobi.br.com/-/s/pro/ws\") # print('链接成功') return ws break except Exception as err: print(err) #print('connect ws error,retry...') time.sleep(1)def getsubconfig(): # 统计参数 tradeStr=[ \"\"\"&#123;\"sub\": \"market.elfusdt.trade.detail\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.btcusdt.trade.detail\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.htusdt.trade.detail\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.swftcbtc.trade.detail\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.topcbtc.trade.detail\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.bchusdt.trade.detail\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.ethusdt.trade.detail\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.etcusdt.trade.detail\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.eosusdt.trade.detail\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.ltcusdt.trade.detail\"&#125;\"\"\" ] return tradeStr# 订阅def sub(ws,tradeStr): ws.send(tradeStr)# 获取返回def getResponse(ws): db = connect_mysql.connect() while 1 : try : compressData=ws.recv() except Exception : ws=connect() subCoin(ws) print('链接异常') try : result=gzip.decompress(compressData).decode('utf-8') except: print('丢包解析异常') continue if result[:7] == '&#123;\"ping\"': ts=result[8:21] #print('心跳包',ts) pong='&#123;\"pong\":'+ts+'&#125;' ws.send(pong) else: if result[:5] == '&#123;\"ch\"': result = json.loads(result) print(result) #print('------------------------------------------------------') n = 0 while n &lt; len(result['tick']['data']) : connect_mysql.commit('%s' % result['ch'].split('.')[1],result['tick']['data'][n]['price'],result['tick']['data'][n]['amount'],\"'%s'\" % result[\"tick\"][\"data\"][n][\"direction\"], \"'%s'\" % result['ch'].split('.')[1],db); n += 1# 订阅def subCoin(ws): tradeStr=getsubconfig() i = 0 while i &lt; len(tradeStr) : sub(ws,tradeStr[i]) i += 1# 主函数def main(): ws=connect() subCoin(ws) getResponse(ws)if __name__ == '__main__': main() 1234567891011121314151617181920212223242526272829### 文件二:```pythonimport jsonimport pymysqlimport timeclass connect_mysql(): db = &apos;&apos; def connect() : db = connect_mysql.db = pymysql.connect(&quot;localhost&quot;, &quot;root&quot;, &quot;root&quot;, &quot;huobi&quot;, charset=&apos;utf8&apos; ) return db def commit(table, price, amount, action, coin_type, db) : try: cursor = db.cursor() sql = &quot;INSERT INTO %s_success_order(action,order_amount, price, coin_type)VALUES (%s, %.10f, %.10f,%s )&quot; % (table,action, amount, price,coin_type ) cursor.execute(sql) # 提交到数据库执行 db.commit() except Exception as e: db = connect_mysql.db = pymysql.connect(&quot;localhost&quot;, &quot;root&quot;, &quot;root&quot;, &quot;huobi&quot;, charset=&apos;utf8&apos; ) commit(table, price, amount, action, coin_type, db) return def connect_close() : connect_mysql.db.close() 文件二是单线程和多线程版的公用文件 shell 脚本123456789101112#!/bin/bashtotal=1avaliable=`ps -ef | grep -w huobi.py | grep -v grep | wc -l`diff=`expr $total - $avaliable`#echo $diff &gt;&gt; /home/script/diff.text#echo $total &gt;&gt; /home/script/diff.text#echo $avaliable &gt;&gt; /home/script/diff.textif [ $diff -gt 0 ];then for((i=0;i&lt;$diff;i++));do /usr/local/bin/python3 /home/script/huobi.py &gt;&gt; /home/script/huobi.out donefi crontab 配置123MAILTO=\"\"* * * * * sudo /bin/bash /home/script/huobi.sh 注意事项：在写shell脚本时，尽量用绝对路径。","tags":[{"name":"python, shell, crond","slug":"python-shell-crond","permalink":"http://yoursite.com/tags/python-shell-crond/"}]},{"title":"一次HTTP请求","date":"2017-11-20T12:09:23.000Z","path":"2017/11/20/一次HTTP请求/","text":"#一次完整的HTTP请求，以及请求方式的区别 今天在对接业务组mas时候遇到一个很少遇到的问题，发送一个一个不但参数的POST的请求。在我的印象里传参好像必带名字，因为就像一个你不认识的人要来你家，你肯定不会让他进来的。所以重新缕了一下POST请求，冲冲能。 ##一次HTTP请求的过程 访问某个网址，例如我们访问www.baidu.com浏览器会和百度的服务器进行三次握手（中间的域名解析等暂不考虑）然后是程序层面的信息请求与提交 三次握手-&gt;get或者post请求 1） Client首先发送一个连接试探，ACK=0 表示确认号无效，SYN = 1 表示这是一个连接请求或连接接受报文，同时表示这个数据报不能携带数据，seq = x 表示Client自己的初始序号（seq = 0 就代表这是第0号包），这时候Client进入syn_sent状态，表示客户端等待服务器的回复 2） Server监听到连接请求报文后，如同意建立连接，则向Client发送确认。TCP报文首部中的SYN 和 ACK都置1 ，ack = x + 1表示期望收到对方下一个报文段的第一个数据字节序号是x+1，同时表明x为止的所有数据都已正确收到（ack=1其实是ack=0+1,也就是期望客户端的第1个包），seq = y 表示Server 自己的初始序号（seq=0就代表这是服务器这边发出的第0号包）。这时服务器进入syn_rcvd，表示服务器已经收到Client的连接请求，等待client的确认。 3） Client收到确认后还需再次发送确认，同时携带要发送给Server的数据。ACK 置1 表示确认号ack= y + 1 有效（代表期望收到服务器的第1个包），Client自己的序号seq= x + 1（表示这就是我的第1个包，相对于第0个包来说的），一旦收到Client的确认之后，这个TCP连接就进入Established状态，就可以发起http请求了。 post请求HTTP 协议是以 ASCII 码传输，建立在TCP/IP协议之上的应用层规范，规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。类似于下面这样： 协议规定 POST 提交的数据必须放在消息主体（entity-body）中，但协议并没有规定数据必须使用什么编码方式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。 但是，数据发送出去，还要服务端解析成功才有意义。一般服务端语言如 php、python 等，以及它们的 framework，都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。所以说到 POST 提交数据方案，包含了 Content-Type 和消息主体编码方式两部分。下面就正式开始介绍它们。 headerContent-Type，内容类型，一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定文件接收方将以什么形式、什么编码读取这个文件.当然还有UA等其他头信息， Content-Type对照表：http://tool.oschina.net/commons 说几种常见的Content-Type 1.application/x-www-form-urlencoded这个就是我们常见form表格提的方式 2.multipart/form-data 这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 form 的 enctyped 等于这个值。直接来看一个请求示例 3.application/json application/json 这个 Content-Type 作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。 so 用这种格式就可以传递非Key Val的数据","tags":[]},{"title":"PHPExcel","date":"2017-10-30T02:42:03.000Z","path":"2017/10/30/PHPExecel/","text":"PHPEXcel 背景在工作中我们肯定会遇到由于后端管理系统不完善，而导致运营同学无法从管理系统获取想要的数据。亦或程序设计之初没有考虑到完善，导致一些必要的数据没有录入，希望后续补充批量导入。在这个时候我们就需要获取从数据批量导出数据或者导入数据，而无论导入还是导出数据，我们都希望是Excel格式。 根据Execel生成sql1.PHPExcel 准备：我们需要从github获取PHPExcel工具包。地址 https://github.com/PHPOffice/PHPExcel 打开PHPExcel文件夹，看下代码结构。我们需要的主要代码在Classes文件下，我们只需要引入PHPExcel.php即可。 代码实现1234567891011121314151617181920212223242526272829include './code/web_code/PHPExcel/Classes/PHPExcel.php';//引入必要的第三方依赖$inputFileType = 'Excel2007';//设置Excel的版本$inputFileName = './targe.xlsx';// 需要导入文件地址$currentsheet = $objPHPExcel-&gt;getSheet(0); //选择Excel页$maxColumn = $currentsheet-&gt;getHighestColumn(); //获取当前页的最大列数$maxRow = $currentsheet-&gt;getHighestRow(); //获取当前页的最大行数//循环拼接sqlfor ($i=2; $i&lt; $maxRow; $i++) &#123; //过滤条件 if(is_null($currentsheet-&gt;getCell('J'.$i)-&gt;getValue())||$currentsheet-&gt;getCell('J'.$i)-&gt;getValue()== '已退款' || $currentsheet-&gt;getCell('J'.$i)-&gt;getValue() == '待退款' || $currentsheet-&gt;getCell('J'.$i)-&gt;getValue() == '已经申请退款' || $currentsheet-&gt;getCell('J'.$i)-&gt;getValue() == '退了' ||$currentsheet-&gt;getCell('J'.$i)-&gt;getValue() == '没有电话' || $currentsheet-&gt;getCell('J'.$i)-&gt;getValue() == '0') &#123; continue; &#125; //过滤条件 if(!is_numeric($currentsheet-&gt;getCell('J'.$i)-&gt;getValue())||$currentsheet-&gt;getCell('J'.$i)-&gt;getValue() == '0' || empty($currentsheet-&gt;getCell('J'.$i)-&gt;getValue()) || $currentsheet-&gt;getCell('J'.$i)-&gt;getValue() == '') &#123; continue; &#125; $sql_bd_name .= ' WHEN '.$currentsheet-&gt;getCell('A'.$i)-&gt;getValue().' THEN '.$currentsheet-&gt;getCell('J'.$i)-&gt;getValue(); $sql_bd_name .= ','.$currentsheet-&gt;getCell('A'.$i)-&gt;getValue(); $res +=1;&#125;//输入，当然这里无论我们用fopen或者其他的输入当属都可以，这里我把结果打到了控制台。echo $sql_bd_name;echo $res 我们生成的sql是WHEN THEN的样式，完整语句应该是 update tablename set seller_jn_activity CASE idWHEN 1 TEHN 2END,bd_jn_activity CASE idwhen 2 THEN 3ENDWHERE in (1,2,3) 发现数据清洗其实是一件很麻烦的事。","tags":[]},{"title":"'laravel学习笔记四中间件'","date":"2016-03-02T11:44:12.000Z","path":"2016/03/02/laravel学习笔记四中间件/","text":"Laravel 学习笔记四Http中间件标签（空格分隔）： laravel 简介 关于中间件，从字面意思上我们很好理解中间件的意思。就是存在两个节点之间的节点。这里我们所描述的节点是Route和Controller。 一次正产给的请求是客户端发送请求，服务端接受请求，然后对参数做一些判断然后处理逻辑。任何请求都会从进入控制器开始就直接进入真正的逻辑处理，我们会先判断请求参数是否正确，以防止黑客攻击。比较常见的处理逻辑反馈有403、503页面。这些是我们在接受参数后对参数进行处理，从而反馈到客户端。如果我们传递参数较多，对参数筛选很严格的话，就会出现很多对参数判断的代码，以及当一些对参数判断的代码需要复用时候我们无法将其从控制器中分离出来，这些都是我们平常工作中饭经常遇到的问题。这是中间件就能很好地处理这个问题了。 间件的作用是在请求从Route进入控制器是时，我们可以先将请求引入到中间件中，对数据做些处理，然后才引入到控制器中，或者直接反馈给客户端。这样我们的控制器可以专心于数据逻辑，从而代码简洁，以及参数判断代码会得到复用，很大的提升工作效率。 创建一个控制器第一步我们来创建一个中间件。在larval中，自带了一条命令用来创建中间件。php artisan make:middleware CheckAge 。我们可以用此命令创建一个CheckAge的中间，用来过滤用户的年龄。穿件代码如下： 12345678910111213141516171819202122232425&lt;?phpnamespace App\\Http\\Middleware;use Closure;class CheckAge&#123; /** * 运行请求过滤器。 * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @return mixed */ public function handle($request, Closure $next) &#123; if ($request-&gt;age &lt;= 200) &#123; return redirect(&apos;home&apos;); &#125; return $next($request); &#125;&#125; 当然在这里少不了路由的代码，我们的请求先到路由，然后到中间件最后到控制器。1Route::get(&apos;getuser/user/&#123;id&#125;/age/&#123;age&#125;&apos;,UserController@getUser)-&gt;middleware(&apos;CheckAge&apos;); 在这段代码中我们把所有请求age大于200的重定向到home中，佛则就继续，这样就是实现了参数过滤。这就是中间件的基本作用。 注册中间件 我们的中间件在使用前，是需要注册的。否则我们无法正常调用到我们的中间件。这个注册文件在app/Http/Kernel.php中。我们打开这个文件。 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpnamespace App\\Http;use Illuminate\\Foundation\\Http\\Kernel as HttpKernel;class Kernel extends HttpKernel&#123; // 这里注册是全局的中间件，在所有的都需要经过这个中间件来过滤信息，无论是来之web的请求还是API的///请求 protected $middleware = [ \\Illuminate\\Foundation\\Http\\Middleware\\CheckForMaintenanceMode::class, ]; // 中间件群组，在这里我们可以注册中间件群组，用来给请求批量的添加空间。这里laravel中web请求默认 //都必须经过web群组的中间的过滤，api请求需要经过api群组的中间件过滤。使用实例在下边已经给出。 protected $middlewareGroups = [ &apos;web&apos; =&gt; [ \\App\\Http\\Middleware\\EncryptCookies::class, \\Illuminate\\Cookie\\Middleware\\AddQueuedCookiesToResponse::class, \\Illuminate\\Session\\Middleware\\StartSession::class, \\Illuminate\\View\\Middleware\\ShareErrorsFromSession::class, \\App\\Http\\Middleware\\VerifyCsrfToken::class, ], &apos;api&apos; =&gt; [ &apos;throttle:60,1&apos;, ], ]; // 非全局的中间件，单独给某些路由指定下面的中间件（用户自己编写）。 protected $routeMiddleware = [ &apos;auth&apos; =&gt; \\App\\Http\\Middleware\\Authenticate::class, &apos;auth.basic&apos; =&gt; \\Illuminate\\Auth\\Middleware\\AuthenticateWithBasicAuth::class, &apos;can&apos; =&gt; \\Illuminate\\Foundation\\Http\\Middleware\\Authorize::class, &apos;guest&apos; =&gt; \\App\\Http\\Middleware\\RedirectIfAuthenticated::class, &apos;throttle&apos; =&gt; \\Illuminate\\Routing\\Middleware\\ThrottleRequests::class, ];&#125; 群组使用123Route::group([&apos;middleware&apos; =&gt; [&apos;web&apos;]], function () &#123; //&#125;) 我们可以看出这个Kernel.php文件中有是哪个属性，分别为 protected $middleware protected $middlewareGroups protected $routeMiddleware 这三个属性分别用来注册全局中间件 群组中间件 和自定义中间件。 特殊中间件在中间件中用连个比较特殊的中间件，分别为前置中间件 和后置中间件。顾名思义，前置中间件就是在请求前运作的，后置中间件就是在请求后运作的。这有什么用呢？我们可以在这里举一个栗子： 在正常的项目中我们肯定要记录一些数据操作记录，用来跟踪每次请求的逻辑处理。方便我们在项目出现bug时候跟踪数据。在laravel中我们用下面函数来进行sql语句的记录：12DB::enableQueryLog();DB::getQueryLog(); 我们可以将DB::enableQueryLog() 放在需要记录sql语句的请求的前置中间件中，用来开启sql记录。将DB::getQueryLog()放在需要记录请求的后置中间件中，记录所执行的sql。 这就是中间件的作用。 中间件参数在调取中间件时，我们可以穿的附加参数。例如：1234567891011121314151617181920212223242526&lt;?phpnamespace App\\Http\\Middleware;use Closure;class CheckRole&#123; /** * 处理传入的请求 * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @param string $role * @return mixed */ public function handle($request, Closure $next, $role) &#123; if (! $request-&gt;user()-&gt;hasRole($role)) &#123; // Redirect... &#125; return $next($request); &#125;&#125; 传递指定参数可以:隔开123Route::put(&apos;post/&#123;id&#125;&apos;, function ($id) &#123; //&#125;)-&gt;middleware(&apos;role:editor&apos;); 好了，本节就到此为止了。","tags":[]},{"title":"Laravel学习笔记三控制器","date":"2016-02-16T13:26:25.000Z","path":"2016/02/16/Laravel学习笔记三控制器/","text":"标签（空格分隔）： Laravel 关于laravel我们学习了如何配置laravel、以及路由。接下来让然是至关重要的控制器了。在MVC框架中，C是一个很重要的环节。用来处理我们的数据逻辑。 我们之前在学习路由是后，是给Route::get()第二个参数一个闭包函数。当然能处理一些数据逻辑，但是如果我们所有的数据逻辑都放在路由文件，那么我们路由文件将会特别臃肿，而且我们的代码耦合度会特别高。这也就回到php面向过程的时代，这不是我们所想要的。 在我们的面向对象的思维中，是把不同功能的代码封装成一个一个类，各自处理自己流水线上的数据。所以我们要通过路由把必要的参数传给我们的控制器去处理。 在这里看到一个小插曲，Laravel官方文档说在上线前使用php artisan route:cache会让路由速度快上一百倍，我不知道这是不是吹牛逼。废话不多说我们开始我们的控制器学习吧。 ###控制器到路由### 在第一步我们需要把访问到路由的请求转到控制器。在Laravel中使用下边代码即可： 'UserController@show');```1234567891011121314 我们可以把客户的请求跳转到 App/Http/Controller下的UserController的show方法。 在这里laravel给我们提供很好的工具让我们来创建控制器。使用`php artisan make:controller NameController` 。默认会出现App/Http/Controller 路径下。并且还有一些级基础代码。```&lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;use App\\Http\\Controllers\\Controller;class NameController extends Controller&#123; //&#125; ###传递参数到控制器### 我们看到在自动生成代码中我们看到引入了Request 类。这个类要讲起来其实可以单独讲，但是我们学到控制器就稍微讲一下，不然没法传递参数。如下1234public function index(Request $request)&#123; $name = $request-&gt;input(&apos;name&apos;); &#125; 用该方法可以获取到我们想要的参数。","tags":[]},{"title":"'laravel学习笔记二路由'","date":"2016-02-09T14:09:19.000Z","path":"2016/02/09/laravel学习笔记二路由/","text":"laravel框架安装好之后我们就要开始熟悉laravel框架的内部结构。我们主要是从这个几个方便来学习laravel： route 路由 controller 控制器 blade 模板 model 模型 今天我们主要讲路由。 laravel-route可能我们在学习laravel之前已经接触过一些框架例如：yii，tp,ci。但是他们都没有laravel所带的路由系统强大，我们现在开始介绍laravel框架的路由。 闭包最基本的路由接受的是一个闭包函数，直接返回值，例如：12Roure::get(&apos;/&apos;,funcition()&#123;return &apos;this is Route&apos;&#125;) 我们在 /routes/web.php 里注册该路由即可返回 this us Route。当然laravel路由所能接受的请求方式不仅仅是get还要post put 等等法法，示例如下123456Route::get($uri, $callback);Route::post($uri, $callback);Route::put($uri, $callback);Route::patch($uri, $callback);Route::delete($uri, $callback);Route::options($uri, $callback); 带参数访问123Roure::get(&apos;/&#123;id&#125;&apos;,function($id)&#123;return &apos;user id is &apos;.$id&#125;) 当然也可以带多参数访问 123Route::get(&apos;/id/&#123;id&#125;/name/&#123;name&#125;&apos;,function($id,$name)&#123;//&#125;) 让然也可以传递一个可选参数 ,但是我们需要用？来标记该参数，还给予他默认值123Route::get(&apos;/name/&#123;name&#125;?&apos;,function($name=&apos;Maxie&apos;)&#123;//&#125;) 路由命名12Roure::get(&apos;/&apos;,funcition()&#123;return &apos;this is Route&apos;&#125;)-&gt;name(&apos;index&apos;) 我们可以给路由命名一个名字，让我们在模板中使用rul函数可以解析到我们所命名的路由url(&#39;index&#39;)。这些我们在模板中在细讲 路由群组路由群组是一个很好东西，我们在开发中很定会给我们的项目分不同模块。例如用户模块，商户模块。这时候我么会给他们加上不同的命名空间，我们可以通过路由群组把我们注册的路由也分类，很方便我们的访问。例如：123Route::groun([&apos;namespace&apos;=&gt;&apos;user&apos;],function()&#123;//我们可以在此注册我们的路由，路由控制器路由会在App/Http/Controller/user 下&#125;) 当让我们可以在群组里继续注册群组，在这里我们不多做演示。 路由绑定到控制器这是我们最关键的地方，一般我们通过访问URI都会想传递参数给我们的控制器，当然laravel还给我们提供了中间件让我们在路路由控制器之间或者路由玉模板之前做一个参数处理或者过滤，我们在此不做演示。后边我们会详细解释，现在我们详细解释路由有绑定到控制器，想必这是你我最关系的。路由绑定到控制器只需要：1Roure::get(&apos;/&apos;,&apos;UserController@showProfile&apos;) 这样既可绑定我么你的路由到控制器。 路由绑定绑定到视图有很多的访问不需要我们做处理，只需展示一些东西既可，我么你可以直接把路由绑定到视图 12345Route::get(&apos;/&apos;,function()&#123;return view(&apos;welcom&apos;)&#125;)这也是我们刚刚配置完laravel时候路由web.php唯一注册一个路由","tags":[]},{"title":"laravel学习笔记","date":"2016-02-08T14:10:05.000Z","path":"2016/02/08/larave学习笔记/","text":"laravel- 学习笔记 laravel 配置篇lavel 有三种安装方法： 使用composer安装 使用laravel安装器安装 下载解压安装 composer先说第一种，使用composer安装，使用 composer create-project 进行安装1composer create-project --prefer-dist laravel/laravel blog laravel安装器 使用laravel安装器首先需要安装laravel安装器，让我们来使用composer安装laravel安装器 1composer global require &quot;laravel/installer&quot; 当然我们在使用laravel安装器安装laravel之前，需要配置PATH环境变量，不然系统找不到laravel安装器laravel安装器默认位置Windows:C:\\Users\\admin\\AppData\\Roaming\\Composer\\vendor\\binlinux:~/.composer/vendor/bin 下载解压安装因为composer可能被墙，所以golaravel给出了已经集成了所有以来的laravel意见安装包下载地址为http://www.golaravel.com/download/ 配置laravel所有的配置文件都在根目录conf文件夹下当然我们不能忽视的一个很重的一点，就是要设置laravel的应用key，如果不加以设置，我的会话和其他需要加密的信息将会不安全，让然我们通过composer或者laravel安装器安装的laravel不需要进行配置，因为在我们安装laravel时候composer和laravel已经给我们配置好了，所以通过第三种方法安装laravel的，需要为laravel配置新的key，生成key的方法是，在laravel根目录输入key:generate.laravel所有的配置都是conf文件夹下的，但是为了方便配置，laravel调用根目录的.env,我们配置框架最关键的数据库信息卸载根目录的.env文件里 开发服务器laravel为我们提供了一个简单的开发服务器，当我需要时只需要在跟路面输入命令php artisan serve即可。但是这毕竟是开发使用过的，不能再生产环境中使用。 #laravel其他laravel还为我们提供很多其他功能，具体我就不在此赘述，需要请看官网。","tags":[]},{"title":"php curl","date":"2015-07-18T12:28:10.000Z","path":"2015/07/18/php-curl/","text":"参数1curl_setoptCURLOPT_RETURNTRANSFER 表示是否直接输出到控制台 eg: 1234567$curl = curl_init();curl_setopt($curl, CURLOPT_URL, 'http://baidu.com');curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);curl_setopt($curl, CURLOPT_HEADER, 0);// curl_setopt($curl, CURLOPT_POST, 1);$ret = curl_exec($curl);// var_dump($ret); 输出结果为: 打开参数 12345678&lt;?php$curl = curl_init();curl_setopt($curl, CURLOPT_URL, &apos;http://baidu.com&apos;);curl_setopt($curl, CURLOPT_RETURNTRANSFER, 0);curl_setopt($curl, CURLOPT_HEADER, 0);// curl_setopt($curl, CURLOPT_POST, 1);$ret = curl_exec($curl);// var_dump($ret); 输出结果 参数2CURLOPT_HEADERCURLOPT_HEADER 表示是否输出头信息 12345678&lt;?php$curl = curl_init();curl_setopt($curl, CURLOPT_URL, &apos;http://baidu.com&apos;);curl_setopt($curl, CURLOPT_RETURNTRANSFER, 0);curl_setopt($curl, CURLOPT_HEADER, 1);// curl_setopt($curl, CURLOPT_POST, 1);$ret = curl_exec($curl);// var_dump($ret); 返回结果 12345678&lt;?php$curl = curl_init();curl_setopt($curl, CURLOPT_URL, &apos;http://baidu.com&apos;);curl_setopt($curl, CURLOPT_RETURNTRANSFER, 0);curl_setopt($curl, CURLOPT_HEADER, 0);// curl_setopt($curl, CURLOPT_POST, 1);$ret = curl_exec($curl);// var_dump($ret); 返回结果 get 与 postget123456789//初始化$curl = curl_init();//设置urlcurl_setopt($curl, CURLOPT_URL, &apos;http://baidu.com&apos;);curl_setopt($curl, CURLOPT_RETURNTRANSFER, 0);curl_setopt($curl, CURLOPT_HEADER, 0);$ret = curl_exec($curl);//关闭curl_close($curl); post 12345678910//初始化$curl = curl_init();//设置urlcurl_setopt($curl, CURLOPT_URL, &apos;http://baidu.com&apos;);curl_setopt($curl, CURLOPT_RETURNTRANSFER, 0);curl_setopt($curl, CURLOPT_HEADER, 0);curl_setopt($curl, CURLOPT_POST, 1);$ret = curl_exec($curl);//关闭curl_close($curl);","tags":[{"name":"curl","slug":"curl","permalink":"http://yoursite.com/tags/curl/"}]},{"title":"github","date":"2015-06-26T14:04:09.000Z","path":"2015/06/26/github/","text":"#关于Git的使用 Git的安装和使用 准备工作： 下载git 客户端 链接地址 下载完毕后，安装一路一下一步。安装完成之后我们开始使用Git使用前我们需要告诉Git，我们是谁。所以需要配置一些信息，来确定我们的身份。 12git config –global user.name “用户名”git config –global user.email “邮箱” 第一条命令用来告诉 git 我们的名字（以后链接github）第二条命令用来告诉git 我们的邮箱 到此我们就可以使用Git了 链接github如果我们希望把自己的项目托管在github我们就需要再做一些配置 首先我们需要生成ssh,使用以下命令1ssh-keygen –t rsa –C 然后他提示的默认路径生成一些文件，或者你自己配置路径。 在生成过程中会让你输入密码，可以不输入，一路回车生成完毕后，会在你选择路径下生成两个文件 一个是 .rsa 一个是 .pub 我们这里只需要.pub里的内容 复制里边的内容 接下来我们需要把文件里的key添加到我们的github账号里。 首先我们登陆我们的github账号。 然后在设置里 NEW SSH KEY 添加描述然后把我们的key复制到里边即可。 不过在提交之前我们还需要做一些配置来确定我们需要把当前库的代码推送到github账号的哪个库里1git remote add origin git@github.com:aaa/xxx 在上边的配置的命令中，aaa表示的我们的github账号。xxx使我们的库文件。以后就可以使用git来进行版本管理和推送到github里了。正常操作代码1234git statusgit add .git commit -a &apos;message&apos;git push 提交完毕。 如果我们需要在其他电脑上使用我们托管的代码，我们需要使用1git pull 或者1git colne &apos;address&apos; 来从github上获取我们所需要的代码 如果在配置过程中出现错误，按照提示的代码解决即可。当然在此如果我们直接使用了1git commit -a 会弹出来vim窗口，在这里写一些vim的命令在非insert状态下我们使用ctrl+d来批量选择#，然后按d删除 在飞插入模式写:wq 保存并推出","tags":[]},{"title":"hexo git github搭建博客","date":"2015-06-02T13:48:07.000Z","path":"2015/06/02/hexo-git-github搭建博客/","text":"在经搭建个人博客、csnd写博客、博客园写博客一系列折腾之后最终决定用 git github hexo 来搭建自己的个人博。我这样做的原因最主要就这么几点： github的大环境。（装逼） 免费稳定1 有一定的技术含量，我个人喜欢折腾。 为了保持使用git的习惯，顺带看看新的技术，跟上时代潮流。 ** 开始**需求环境 git git下载地址 node.js node.js下载地址 两个安装都是一路下一步 验证软件正确安装git --version node -v npm -v 如果显示版本信息，怎安装成功。 安装hexo在这里如果被墙的可以使用淘宝镜像cnpm 具体怎么操作可以自行百度，这里不多做解释。不过一般不会被墙，我使用npm。运行下边的命令安装hexo：被墙请使用命令： npm install -g cnpm --registry=https://registry.npm.taobao.org 以下是没有被墙的命令，被墙把npm换成cnpm即可。安装hexo npm install hexo-cli -g 安装完成后，验证是否安装成功。 hexo -v 新建文件夹yourblog,输入命令 $ hexo init blog $ cd blog 新建博客 $ hexo new &quot;Hello Hexo&quot; 生成静态页面 $ hexo generate 运行服务 $ hexo server 然后打开浏览器输入 localhost:4000 即可访问本地静态页面。 接下来我们把本地静态页面PUSH到github 首先你要有github账号。 新建一个github.io的库 设置本地github配置参数 经本地静态页面push到github github设置 新建github账号就不在这里陈述了，如果有同学不会使用git将代码push到github的话可以参考 廖雪峰的官网我们来直接进行第二不，创建一个github.io库。首先登陆我们的github账号点击new repository,然后输入youname.github.iogit设置设置git配置信息 $ git config --global user.name &quot;你的用户名&quot; $ git config --global user.email &quot;你的邮箱&quot; hexo 设置 安装hexo git插件 npm install hexo-deployer-git --save 然后打开博客根目录的_config.yml文件大致内容是这个样子的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: 和女票抢可乐subtitle:description:author: MaxieLjlanguage:timezone:# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://yoursite.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: yilia# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/MaxieLj/MaxieLj.github.io.git branch: masterjsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 我们只需要在尾部添加：1234deploy: type: git repository: https://github.com/MaxieLj/MaxieLj.github.io.git branch: master 然后我们运行 $ hexo g 生成静态文件然后推送到github $ hexo d 然后访问youname.github.io就可以看到生成的静态页面了当然我们一般是在本地调试好再用 hexo d推送到github","tags":[]}]