[{"title":"如何建立一个composer私有包","date":"2018-09-28T09:11:00.000Z","path":"2018/09/28/如何建立一个composer私有包/","text":"最近发现分布式锁在很多项目都有所用到,所以想把之前完成的代码封装成pear包,供大家使用。但是发现自己对composer并不是很熟悉,所以学习一番,在此记录以防自己忘记。 新建仓库$ git clone git@gitlab.renrenche.com:web/jugg.git$ cd jugg conmposer 初始化composer init 123456789101112131415161718//包名Package name (&lt;vendor&gt;/&lt;name&gt;) [lijian/test_composer]: jugg/jugg//描述Description []: 基于redis的分布式锁//作者Author [, n to skip]: Maxie lj &lt;xiaolijian110@163.com&gt;//最小稳定版本Minimum Stability []: dev//遵循协议License []: MIT//依赖Would you like to define your dependencies (require) interactively [yes]? yesSearch for a package: phpEnter the version constraint to require (or leave blank to use the latest version):Using version ^7.0 for php 生成composer.json文件 12345678910111213141516171819&#123; &quot;name&quot;: &quot;jugg/jugg&quot;, &quot;description&quot;: &quot;基于redis的分布式锁&quot;, &quot;type&quot;: &quot;library&quot;, &quot;require&quot;: &#123; &quot;php&quot;: &quot;^7.0&quot; &#125;, &quot;require-dev&quot;: &#123; &quot;php&quot;: &quot;7&quot; &#125;, &quot;license&quot;: &quot;MIT&quot;, &quot;authors&quot;: [ &#123; &quot;name&quot;: &quot;Maxie lj&quot;, &quot;email&quot;: &quot;xiaolijian110@163.com&quot; &#125; ], &quot;minimum-stability&quot;: &quot;dev&quot;&#125; 生成自动加载（psr-4）在composer.json 文件里添加123456789101112131415161718&#123; &quot;name&quot;: &quot;jugg/jugg&quot;, &quot;description&quot;: &quot;基于redis的分布式锁&quot;, &quot;type&quot;: &quot;library&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;authors&quot;: [ &#123; &quot;name&quot;: &quot;Maxie lj&quot;, &quot;email&quot;: &quot;xiaolijian110@163.com&quot; &#125; ], &quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;Jugg\\\\&quot;: &quot;jugg&quot; &#125; &#125;, &quot;minimum-stability&quot;: &quot;dev&quot;&#125; 执行composer install 就会生成一个自动加载文件 然后我们就可以按照psr-4规范开发我们pear包了。 测试我们可以在测试文件里引入autoload.php文件,这样就实现了自动加载。 1require './vendor/autoload.php'; 这样就可以正常的测试了 上传代码到gitlab或者github当我们开完的时候,需要将我们的代码上传到远程代码库。 需要注意的事 一定不要讲.git文件上传。 其他项目引入因为没有上传到pagelist,所以我们暂时是公司私有包。 如果需要再项目里引入私有包,需要在项目的composer.json文件里添加。 1234567891011121314151617&quot;jugg&quot;: &#123; &quot;type&quot;:&quot;package&quot;, &quot;package&quot;: &#123; &quot;name&quot;: &quot;jugg&quot;, &quot;version&quot;: &quot;v1.1&quot;, &quot;source&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;git@gitlab.renrenche.com:web/jugg.git&quot;, &quot;reference&quot;: &quot;master&quot; &#125;, &quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;Jugg\\\\&quot;: &quot;jugg&quot; &#125; &#125; &#125; &#125; 完整文件: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129&#123; &quot;name&quot;: &quot;laravel/lumen&quot;, &quot;description&quot;: &quot;The Laravel Lumen Framework.&quot;, &quot;keywords&quot;: [ &quot;framework&quot;, &quot;laravel&quot;, &quot;lumen&quot; ], &quot;license&quot;: &quot;MIT&quot;, &quot;type&quot;: &quot;project&quot;, &quot;repositories&quot;: &#123; &quot;packagist&quot;: &#123; &quot;type&quot;: &quot;composer&quot;, &quot;url&quot;: &quot;https://packagist.phpcomposer.com&quot; &#125;, &quot;0&quot;: &#123; &quot;type&quot;: &quot;package&quot;, &quot;package&quot;: &#123; &quot;name&quot;: &quot;sdk/clusterproxy&quot;, &quot;version&quot;: &quot;1.0.3&quot;, &quot;source&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;git@gitlab.renrenche.com:sdk/clusterproxy.git&quot;, &quot;reference&quot;: &quot;master&quot; &#125;, &quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;Cluster\\\\&quot;: &quot;src/Cluster&quot; &#125; &#125; &#125; &#125;, &quot;1&quot;: &#123; &quot;type&quot;: &quot;package&quot;, &quot;package&quot;: &#123; &quot;name&quot;: &quot;sdk/dingtalk-alarm-php-sdk&quot;, &quot;version&quot;: &quot;1.0&quot;, &quot;source&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;git@gitlab.renrenche.com:sdk/dingtalk-alarm-php-sdk.git&quot;, &quot;reference&quot;: &quot;master&quot; &#125;, &quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;Rrc\\\\&quot;: &quot;src/Rrc/&quot; &#125; &#125; &#125; &#125;, &quot;2&quot;: &#123; &quot;type&quot;:&quot;package&quot;, &quot;package&quot;: &#123; &quot;name&quot;: &quot;sdk/prometheus-php-sdk&quot;, &quot;version&quot;: &quot;1.0&quot;, &quot;source&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;git@gitlab.renrenche.com:sdk/prometheus-php-sdk.git&quot;, &quot;reference&quot;: &quot;master&quot; &#125;, &quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;Rrc\\\\&quot;: &quot;src/Rrc/&quot; &#125; &#125; &#125; &#125;, &quot;jugg&quot;: &#123; &quot;type&quot;:&quot;package&quot;, &quot;package&quot;: &#123; &quot;name&quot;: &quot;jugg&quot;, &quot;version&quot;: &quot;v1.1&quot;, &quot;source&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;git@gitlab.renrenche.com:web/jugg.git&quot;, &quot;reference&quot;: &quot;master&quot; &#125;, &quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;Jugg\\\\&quot;: &quot;jugg&quot; &#125; &#125; &#125; &#125; &#125;, &quot;require&quot;: &#123; &quot;php&quot;: &quot;&gt;=7.0&quot;, &quot;laravel/lumen-framework&quot;: &quot;5.5.*&quot;, &quot;vlucas/phpdotenv&quot;: &quot;~2.2&quot;, &quot;guzzlehttp/guzzle&quot;: &quot;^6.2&quot;, &quot;sdk/clusterproxy&quot;: &quot;^1.0&quot;, &quot;illuminate/redis&quot;: &quot;^5.3&quot;, &quot;peixinchen/mns&quot;: &quot;^1.0&quot;, &quot;mockery/mockery&quot;: &quot;^0.9.5&quot;, &quot;firebase/php-jwt&quot;: &quot;^4.0&quot;, &quot;sdk/dingtalk-alarm-php-sdk&quot;: &quot;^1.0&quot;, &quot;sdk/prometheus-php-sdk&quot;: &quot;^1.0&quot;, &quot;predis/predis&quot;: &quot;^1.1&quot;, &quot;solarium/solarium&quot;: &quot;^3.8&quot;, &quot;mongodb/mongodb&quot;: &quot;^1.3&quot;, &quot;jugg&quot;: &quot;^1.0&quot; &#125;, &quot;require-dev&quot;: &#123; &quot;fzaninotto/faker&quot;: &quot;~1.4&quot;, &quot;phpunit/phpunit&quot;: &quot;~6.0&quot;, &quot;mockery/mockery&quot;: &quot;~0.9&quot;, &quot;phpstan/phpstan&quot;: &quot;^0.9.2&quot; &#125;, &quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;Rrc\\\\&quot;: &quot;./&quot; &#125; &#125;, &quot;autoload-dev&quot;: &#123; &quot;classmap&quot;: [ &quot;tests/&quot;, &quot;database/&quot; ] &#125;, &quot;scripts&quot;: &#123; &quot;post-root-package-install&quot;: [ &quot;php -r \\&quot;copy(&apos;.env.example&apos;, &apos;.env&apos;);\\&quot;&quot; ] &#125;, &quot;minimum-stability&quot;: &quot;dev&quot;, &quot;prefer-stable&quot;: true, &quot;config&quot;: &#123; &quot;optimize-autoloader&quot;: true &#125;&#125; 然后执行composer require jugg&lt;包名&gt; 就可以引入到项目里了。","tags":[]},{"title":"使用guzzle并行请求","date":"2018-09-28T09:10:05.000Z","path":"2018/09/28/使用guzzle并行请求/","text":"背景由于拍卖项目特有的点特, 会导致在开拍是有瞬时的高流量。后端系统会每个出价排序, 由于高qps导致排序会有重复的情况,。为了解决遮掩样的问题,就写了一个分布式锁, 用于解决排序冲突。用guzzle写了一个压测脚本。 实现首先压测是为了同一时刻发送指定数量的请求到目标接口。所以串行话的请求是无法guzzle 支持用pool实现并行的请求。官方文档 : 官方文档支持 文档中并没有提示如何发送POST请求, 顾琢磨一下: 并行方式请求: 12345678910111213141516171819202122232425262728293031$client = new Client(['base_uri' =&gt; '10.171.22.45:5005', 'timeout' =&gt; 10]); $requests = function ($total) &#123; $uri = 'api/v1/bid'; for ($i = 0; $i &lt; $total; $i++) &#123; yield new Request('POST', $uri, ['Content-type' =&gt; 'application/json'],json_encode([ 'car_dealer_id'=&gt; (string)rand(1,20000), 'bid_price' =&gt; \"4\", 'car_id' =&gt; \"206431344\", 'fr' =&gt; 'bd_other', 'platform' =&gt; 'MO', 'source' =&gt; 'C2B竞价', 'sale_type' =&gt; '卖车', 'car_dealer_city' =&gt; '深圳', 'app_version' =&gt; \"3.2\" ])); &#125; &#125;; $pool = new Pool($client, $requests(100), [ 'concurrency' =&gt; 5, 'fulfilled' =&gt; function ($response, $index) &#123; var_dump($response-&gt;getBody()-&gt;getContents()); &#125;, 'rejected' =&gt; function ($reason, $index) &#123; var_dump($reason-&gt;getMessage()); &#125;, ]); $promise = $pool-&gt;promise(); $promise-&gt;wait(); 串行: 123456789101112131415161718192021for ($i =1 ; $i&lt;20;$i++) &#123; echo time(); $org_res[] = $this-&gt;client-&gt;request('POST', 'api/v1/bid',['form_params'=&gt; [ 'car_dealer_id'=&gt; rand(1,20000), 'bid_price' =&gt; 4, 'car_id' =&gt; 206431332, 'fr' =&gt; 'bd_other', 'platform' =&gt; 'MO', 'source' =&gt; 'C2B竞价', 'sale_type' =&gt; '卖车', 'car_dealer_city' =&gt; '深圳', 'app_version' =&gt; 3.2 ]]);&#125;foreach ($org_res as $val) &#123; $resdata = $val-&gt;getBody()-&gt;getContents();&#125;var_dump($resdata);die; 请求结果: 两者区别 从性能上来看,20次请求, 并行请求耗时2秒, 串行请求3秒。 当请求加到100次的时候, 并行请求耗时6秒, 串行请求耗时27秒,这个时候就能体现出并行和串行的却别相差21秒。 为什么会有这么差距,再上一张图和代码,打印出来开始结束时间。 并行:1234567891011121314151617181920212223242526272829303132333435363738并行请求 echo '总的开始:'.microtime().'&lt;br&gt;'; $client = new Client(['base_uri' =&gt; '10.171.22.45:5005', 'timeout' =&gt; 10]); $requests = function ($total) &#123; $uri = 'api/v1/bid'; for ($i = 0; $i &lt; $total; $i++) &#123; $car_dealer_id = (string)rand(1,1000000); echo '开始'.microtime().' car_dealer_id:'.$car_dealer_id.\"&lt;br&gt;\"; yield new Request('POST', $uri, ['Content-type' =&gt; 'application/json'],json_encode([ 'car_dealer_id'=&gt; (string)$car_dealer_id, 'bid_price' =&gt; \"4\", 'car_id' =&gt; \"206431344\", 'fr' =&gt; 'bd_other', 'platform' =&gt; 'MO', 'source' =&gt; 'C2B竞价', 'sale_type' =&gt; '卖车', 'car_dealer_city' =&gt; '深圳', 'app_version' =&gt; \"3.2\" ])); &#125; &#125;; $pool = new Pool($client, $requests(100), [ 'concurrency' =&gt; 5, 'fulfilled' =&gt; function ($response, $index) &#123; var_dump($response-&gt;getBody()-&gt;getContents()); echo microtime().\"&lt;br&gt;\"; &#125;, 'rejected' =&gt; function ($reason, $index) &#123; var_dump($reason-&gt;getMessage()); echo microtime(); &#125;, ]); $promise = $pool-&gt;promise(); $promise-&gt;wait(); echo '总的结束:'.microtime().'&lt;br&gt;'; 100次请求的返回结果 串行: 123456789101112131415161718192021222324 for ($i =1 ; $i&lt;100;$i++) &#123; echo '开始时间'.microtime().\"&lt;br&gt;\"; $ret = $this-&gt;client-&gt;request('POST', 'api/v1/bid',['form_params'=&gt; [ 'car_dealer_id'=&gt; rand(1,2000000), 'bid_price' =&gt; 4, 'car_id' =&gt; 206431332, 'fr' =&gt; 'bd_other', 'platform' =&gt; 'MO', 'source' =&gt; 'C2B竞价', 'sale_type' =&gt; '卖车', 'car_dealer_city' =&gt; '深圳', 'app_version' =&gt; 3.2 ]]); $org_res[] = $ret; echo '结束时间'.microtime().\"&lt;br&gt;\"; var_export($ret-&gt;getBody()-&gt;getContents()); &#125;// foreach ($org_res as $val) &#123;// $resdata[] = $val-&gt;getBody()-&gt;getContents();// &#125;// var_dump($resdata); die; 100次请求的返回结果 所以可以看出,并行请求是先生成所有请求（这个上限和concurrency 参数有关）,再等待结果。如果达到当前并行的上线,就等待请求结束再生成新的请求。 串行请求为请求,等待结果然后在请求。 所以如果请求量很大的话,尽量还是用并行请求。","tags":[{"name":"压测","slug":"压测","permalink":"http://yoursite.com/tags/压测/"}]},{"title":"php垃圾回收","date":"2018-09-12T13:28:00.000Z","path":"2018/09/12/php垃圾回收/","text":"php是如何实现内存管理的?内存管理无非包括内存分配、内存回收、以及内存使用优化。 内存使用的优化 垃圾回收机制 底层内存分配 内存使用的优化引用计数php的引用中有个引用结构体 12345```cstruct _zend_reference &#123; zend_refcondted_h gc; zval val; 指向原来的value.&#125;; 123456789101112131415161718其中`zend_refcondted_h` 便是gc便是当前变量被引用的次数,这个参数会在变量回收的时候用到。zend_refcondted_h :```ctypedef struct _zend_refcounted_h &#123; uint32_t refcount; /* reference counter 32-bit */ union &#123; struct &#123; ZEND_ENDIAN_LOHI_3( zend_uchar type, zend_uchar flags, /* used for strings &amp; objects */ uint16_t gc_info) /* keeps GC root number (or 0) and color */ &#125; v; uint32_t type_info; &#125; u;&#125; zend_refcounted_h; 在实际中这个结构体到底是什么样的? 具体可以举例来看。 1234$a = 'this is string'; // zend_array (refcount = 1) 只有$a引用了zend_array$b = &amp;$a; // zend_array (refcount = 2) $a、$b引用了zend_array$c = $b; // zend_array (refcount = 3) $a、$b、$c引用了zend_arrayunset($b); // zend_array (refcount = 2) $a、$c引用了zend_array 并不是所有的变量类型都会使用引用计数, 例如 整形、浮点型、布尔型、NUll(在php中这是一个变量类型)等采用了深拷贝,即只要这几种变量赋值, 就会申请一款一块内存写入一个新的变量结构（注意这里不是引用结构）,当然这些类型不会公用value。 写时复制当然只有引用计数是不够的, 因为变量会发生赋值的情况。所以在更改某一个变量时, 会对原来的变量进行拷贝并赋值。 举个栗子: 12345$foo = time();$bar = &amp;$b;$si = $a;$c = &apos;123&apos;; 具体数据结构的引用计数情况如下图: 内存回收自动gc在zend数据接口中有一个gc.refount,他是自动gc的关键。 在自动gc机制中,如果zval不在指向value且当前value的gc.refount为0时,会直接释放value。这种情况多发生于函数返回时（销毁所有局部变量）、变量修改时、以及unset操作的时候。 辣鸡回收除了自动gc,还有一种是自动gc无法处理的垃圾, 这种情况称为循环引用。顾名思义也就是自身内部变量引用了自身, 这种情况常出现与object和array。当我该变量zval被销毁是, 与其对应的value gc.refcount -1,但是因为有自身变量指向自身, 所以就陷入了一个循环:如果不销毁自身变量 value gc.refcount就无法自动gc, 只有自动gc才会销毁value。 1234$a = [1];$a[] = &amp;$a;unset($a); unset($a)执行以后 由于\b上述情况导致无法自动gc,所以需要引入另外一钟垃圾回收机制-垃圾回收器。现在会存在两种情况的数据需要回收： 当value的gc.refcount =0 是需要回收。 当value的gc.refcount 减少不等于0，但是存在循环引用时。 回收机制当发生value gc.refcount减少时，垃圾回收机制会把可能是垃圾的value存起来， 当可能是辣鸡的value到达一定数量的时候启动垃圾鉴别程序，统一处理垃圾。当然这里的value类型只有object和array。 垃圾兼备程序：其实垃圾鉴别程序很简单，递归遍历自身value，查看是否存在指向自身的即可。 code:gc 初始化1234567891011ZEND_API void gc_init(void)&#123; if (GC_G(buf) == NULL &amp;&amp; GC_G(gc_enabled)) &#123; //初始化buf\b内存区域，大小为sizeof(gc_root_buffer) * //GC_ROOT_BUFFER_MAX_ENTRIES GC_G(buf) = (gc_root_buffer*) malloc(sizeof(gc_root_buffer) * GC_ROOT_BUFFER_MAX_ENTRIES); //设置_zend_gc_globals.last_unused为\b\bbug入口位置 GC_G(last_unused) = &amp;GC_G(buf)[GC_ROOT_BUFFER_MAX_ENTRIES]; //初始化_zend_gc_globals的参数 gc_reset(); &#125;&#125; 垃圾回收及其依赖 _zend_gc_globals _zend_gc_globals1234567891011121314151617181920212223242526272829typedef struct _zend_gc_globals &#123; zend_bool gc_enabled; zend_bool gc_active; zend_bool gc_full; gc_root_buffer *buf; /* preallocated arrays of buffers */ gc_root_buffer roots; /* list of possible roots of cycles */ gc_root_buffer *unused; /* list of unused buffers */ gc_root_buffer *first_unused; /* pointer to first unused buffer */ gc_root_buffer *last_unused; /* pointer to last unused buffer */ gc_root_buffer to_free; /* list to free */ gc_root_buffer *next_to_free; uint32_t gc_runs; uint32_t collected;#if GC_BENCH uint32_t root_buf_length; uint32_t root_buf_peak; uint32_t zval_possible_root; uint32_t zval_buffered; uint32_t zval_remove_from_buffer; uint32_t zval_marked_grey;#endif gc_additional_buffer *additional_buffer;&#125; zend_gc_globals; gc_enabled 是否使使用gc gc_active 是否在垃圾检查的过程中 gc_full buf缓冲区是否已满 *buf 与分配用于保存可能为垃圾的value roots 指向buf最新加入的一个可能垃圾 unused 指向第未使用的buffer *first_unused 指向第一个没用使用buffer *last_unused 指向buffer的尾部 to_free 等待释放的buffer gc_runs 统计gc运行的次数 collected 统计已经释放的垃圾数 php垃圾回收中几个重要的颜色写在zeng_gc的备注中。1234* BLACK (GC_BLACK) - In use or free.* GREY (GC_GREY) - Possible member of cycle.* WHITE (GC_WHITE) - Member of garbage cycle.* PURPLE (GC_PURPLE) - Possible root of cycle. GC_WHITE 白色表示垃圾 GC_PURPLE 紫色表示已放入缓冲区 GC_GREY 灰色表示已经进行了一次refcount的减一操作 GC_BLACK 黑色是默认颜色，正常 gc过程中主要处理功能的函数zend_gc_collect_cycles 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657ZEND_API void ZEND_FASTCALL gc_possible_root(zend_refcounted *ref)&#123; gc_root_buffer *newRoot; if (UNEXPECTED(CG(unclean_shutdown)) || UNEXPECTED(GC_G(gc_active))) &#123; return; &#125; ZEND_ASSERT(GC_TYPE(ref) == IS_ARRAY || GC_TYPE(ref) == IS_OBJECT); ZEND_ASSERT(EXPECTED(GC_REF_GET_COLOR(ref) == GC_BLACK)); ZEND_ASSERT(!GC_ADDRESS(GC_INFO(ref))); GC_BENCH_INC(zval_possible_root); newRoot = GC_G(unused); if (newRoot) &#123; GC_G(unused) = newRoot-&gt;prev; &#125; else if (GC_G(first_unused) != GC_G(last_unused)) &#123; newRoot = GC_G(first_unused); GC_G(first_unused)++; &#125; else &#123; //垃圾处理，当缓冲区满时，程序调用gc_collect_cycles函数，执行垃圾回收操作。 其中最关键的几步就是 //如果当前处于可以gc的状态 if (!GC_G(gc_enabled)) &#123; return; &#125; GC_REFCOUNT(ref)++; //垃圾回收 gc_collect_cycles(); GC_REFCOUNT(ref)--; if (UNEXPECTED(GC_REFCOUNT(ref)) == 0) &#123; zval_dtor_func(ref); return; &#125; if (UNEXPECTED(GC_INFO(ref))) &#123; return; &#125; newRoot = GC_G(unused); if (!newRoot) &#123; return; &#125; GC_G(unused) = newRoot-&gt;prev; &#125; GC_TRACE_SET_COLOR(ref, GC_PURPLE); GC_INFO(ref) = (newRoot - GC_G(buf)) | GC_PURPLE; newRoot-&gt;ref = ref; newRoot-&gt;next = GC_G(roots).next; newRoot-&gt;prev = &amp;GC_G(roots); GC_G(roots).next-&gt;prev = newRoot; GC_G(roots).next = newRoot; GC_BENCH_INC(zval_buffered); GC_BENCH_INC(root_buf_length); GC_BENCH_PEAK(root_buf_peak, root_buf_length);&#125; \bdebug代码已删除 \b深度优先对对象或者数据的每一个元素的refcount--并将其标记为灰色 深度遍历root的每个每个变量，如果此时变量的refcount为0，则代表着改变量为垃圾，将其标记为垃圾，如果不为0，则将其标记为黑色（正常）。 检查roots清除标记为白色的垃圾。 //TODO 垃圾回收抽出来出来写。 具体代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164ZEND_API int zend_gc_collect_cycles(void)&#123; int count = 0; if (GC_G(roots).next != &amp;GC_G(roots)) &#123; gc_root_buffer *current, *next, *orig_next_to_free; zend_refcounted *p; gc_root_buffer to_free; uint32_t gc_flags = 0; gc_additional_buffer *additional_buffer_snapshot; if (GC_G(gc_active)) &#123; return 0; &#125; GC_TRACE(\"Collecting cycles\"); //标识gc运行了多少次 GC_G(gc_runs)++; //标识当前正在gc GC_G(gc_active) = 1; GC_TRACE(\"Marking roots\"); //重点 gc_mark_roots(); GC_TRACE(\"Scanning roots\"); //重点 gc_scan_roots(); GC_TRACE(\"Collecting roots\"); additional_buffer_snapshot = GC_G(additional_buffer); count = gc_collect_roots(&amp;gc_flags); GC_G(gc_active) = 0; if (GC_G(to_free).next == &amp;GC_G(to_free)) &#123; /* nothing to free */ GC_TRACE(\"Nothing to free\"); return 0; &#125; /* Copy global to_free list into local list */ to_free.next = GC_G(to_free).next; to_free.prev = GC_G(to_free).prev; to_free.next-&gt;prev = &amp;to_free; to_free.prev-&gt;next = &amp;to_free; /* Free global list */ GC_G(to_free).next = &amp;GC_G(to_free); GC_G(to_free).prev = &amp;GC_G(to_free); orig_next_to_free = GC_G(next_to_free); if (gc_flags &amp; GC_HAS_DESTRUCTORS) &#123; GC_TRACE(\"Calling destructors\"); /* Remember reference counters before calling destructors */ current = to_free.next; while (current != &amp;to_free) &#123; current-&gt;refcount = GC_REFCOUNT(current-&gt;ref); current = current-&gt;next; &#125; /* Call destructors */ current = to_free.next; while (current != &amp;to_free) &#123; p = current-&gt;ref; GC_G(next_to_free) = current-&gt;next; if (GC_TYPE(p) == IS_OBJECT) &#123; zend_object *obj = (zend_object*)p; if (!(GC_FLAGS(obj) &amp; IS_OBJ_DESTRUCTOR_CALLED)) &#123; GC_TRACE_REF(obj, \"calling destructor\"); GC_FLAGS(obj) |= IS_OBJ_DESTRUCTOR_CALLED; if (obj-&gt;handlers-&gt;dtor_obj &amp;&amp; (obj-&gt;handlers-&gt;dtor_obj != zend_objects_destroy_object || obj-&gt;ce-&gt;destructor)) &#123; GC_REFCOUNT(obj)++; obj-&gt;handlers-&gt;dtor_obj(obj); GC_REFCOUNT(obj)--; &#125; &#125; &#125; current = GC_G(next_to_free); &#125; /* Remove values captured in destructors */ current = to_free.next; while (current != &amp;to_free) &#123; GC_G(next_to_free) = current-&gt;next; if (GC_REFCOUNT(current-&gt;ref) &gt; current-&gt;refcount) &#123; gc_remove_nested_data_from_buffer(current-&gt;ref, current); &#125; current = GC_G(next_to_free); &#125; &#125; /* Destroy zvals */ GC_TRACE(\"Destroying zvals\"); GC_G(gc_active) = 1; current = to_free.next; while (current != &amp;to_free) &#123; p = current-&gt;ref; GC_G(next_to_free) = current-&gt;next; GC_TRACE_REF(p, \"destroying\"); if (GC_TYPE(p) == IS_OBJECT) &#123; zend_object *obj = (zend_object*)p; EG(objects_store).object_buckets[obj-&gt;handle] = SET_OBJ_INVALID(obj); GC_TYPE(obj) = IS_NULL; if (!(GC_FLAGS(obj) &amp; IS_OBJ_FREE_CALLED)) &#123; GC_FLAGS(obj) |= IS_OBJ_FREE_CALLED; if (obj-&gt;handlers-&gt;free_obj) &#123; GC_REFCOUNT(obj)++; obj-&gt;handlers-&gt;free_obj(obj); GC_REFCOUNT(obj)--; &#125; &#125; SET_OBJ_BUCKET_NUMBER(EG(objects_store).object_buckets[obj-&gt;handle], EG(objects_store).free_list_head); EG(objects_store).free_list_head = obj-&gt;handle; p = current-&gt;ref = (zend_refcounted*)(((char*)obj) - obj-&gt;handlers-&gt;offset); &#125; else if (GC_TYPE(p) == IS_ARRAY) &#123; zend_array *arr = (zend_array*)p; GC_TYPE(arr) = IS_NULL; /* GC may destroy arrays with rc&gt;1. This is valid and safe. */ HT_ALLOW_COW_VIOLATION(arr); zend_hash_destroy(arr); &#125; current = GC_G(next_to_free); &#125; /* Free objects */ current = to_free.next; while (current != &amp;to_free) &#123; next = current-&gt;next; p = current-&gt;ref; if (EXPECTED(current &gt;= GC_G(buf) &amp;&amp; current &lt; GC_G(buf) + GC_ROOT_BUFFER_MAX_ENTRIES)) &#123; current-&gt;prev = GC_G(unused); GC_G(unused) = current; &#125; efree(p); current = next; &#125; while (GC_G(additional_buffer) != additional_buffer_snapshot) &#123; gc_additional_buffer *next = GC_G(additional_buffer)-&gt;next; efree(GC_G(additional_buffer)); GC_G(additional_buffer) = next; &#125; GC_TRACE(\"Collection finished\"); GC_G(collected) += count; GC_G(next_to_free) = orig_next_to_free; GC_G(gc_active) = 0; &#125; return count;&#125; 123456789101112static void gc_mark_roots(void)&#123; gc_root_buffer *current = GC_G(roots).next; while (current != &amp;GC_G(roots)) &#123; //GC_PURPLE 标识在缓冲区 if (GC_REF_GET_COLOR(current-&gt;ref) == GC_PURPLE) &#123; gc_mark_grey(current-&gt;ref); &#125; current = current-&gt;next; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104static void gc_mark_grey(zend_refcounted *ref)&#123; HashTable *ht; Bucket *p, *end; zval *zv;tail_call: if (GC_REF_GET_COLOR(ref) != GC_GREY) &#123; ht = NULL; GC_BENCH_INC(zval_marked_grey); GC_REF_SET_COLOR(ref, GC_GREY); if (GC_TYPE(ref) == IS_OBJECT) &#123; zend_object_get_gc_t get_gc; zend_object *obj = (zend_object*)ref; if (EXPECTED(!(GC_FLAGS(ref) &amp; IS_OBJ_FREE_CALLED) &amp;&amp; (get_gc = obj-&gt;handlers-&gt;get_gc) != NULL)) &#123; int n; zval *zv, *end; zval tmp; ZVAL_OBJ(&amp;tmp, obj); ht = get_gc(&amp;tmp, &amp;zv, &amp;n); end = zv + n; if (EXPECTED(!ht)) &#123; if (!n) return; while (!Z_REFCOUNTED_P(--end)) &#123; //表明当前object size为0 if (zv == end) return; &#125; &#125; while (zv != end) &#123; //循环对每个元素进行-- if (Z_REFCOUNTED_P(zv)) &#123; ref = Z_COUNTED_P(zv); GC_REFCOUNT(ref)--; //refcount已经减过，标记为灰色 gc_mark_grey(ref); &#125; zv++; &#125; if (EXPECTED(!ht)) &#123; ref = Z_COUNTED_P(zv); GC_REFCOUNT(ref)--; goto tail_call; &#125; &#125; else &#123; return; &#125; &#125; else if (GC_TYPE(ref) == IS_ARRAY) &#123; if (((zend_array*)ref) == &amp;EG(symbol_table)) &#123; //标识是正常非垃圾 GC_REF_SET_BLACK(ref); return; &#125; else &#123; ht = (zend_array*)ref; &#125; &#125; else if (GC_TYPE(ref) == IS_REFERENCE) &#123; if (Z_REFCOUNTED(((zend_reference*)ref)-&gt;val)) &#123; ref = Z_COUNTED(((zend_reference*)ref)-&gt;val); GC_REFCOUNT(ref)--; goto tail_call; &#125; return; &#125; else &#123; return; &#125; if (!ht-&gt;nNumUsed) return; p = ht-&gt;arData; end = p + ht-&gt;nNumUsed; while (1) &#123; end--; zv = &amp;end-&gt;val; if (Z_TYPE_P(zv) == IS_INDIRECT) &#123; zv = Z_INDIRECT_P(zv); &#125; if (Z_REFCOUNTED_P(zv)) &#123; break; &#125; if (p == end) return; &#125; while (p != end) &#123; zv = &amp;p-&gt;val; if (Z_TYPE_P(zv) == IS_INDIRECT) &#123; zv = Z_INDIRECT_P(zv); &#125; if (Z_REFCOUNTED_P(zv)) &#123; ref = Z_COUNTED_P(zv); GC_REFCOUNT(ref)--; gc_mark_grey(ref); &#125; p++; &#125; zv = &amp;p-&gt;val; if (Z_TYPE_P(zv) == IS_INDIRECT) &#123; zv = Z_INDIRECT_P(zv); &#125; ref = Z_COUNTED_P(zv); GC_REFCOUNT(ref)--; goto tail_call; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798static void gc_scan(zend_refcounted *ref)&#123; HashTable *ht; Bucket *p, *end; zval *zv;tail_call: if (GC_REF_GET_COLOR(ref) == GC_GREY) &#123; if (GC_REFCOUNT(ref) &gt; 0) &#123; //所有refount--以后如果还&gt;0，说明非垃圾 gc_scan_black(ref); &#125; else &#123; //否则则为垃圾 GC_REF_SET_COLOR(ref, GC_WHITE); if (GC_TYPE(ref) == IS_OBJECT) &#123; zend_object_get_gc_t get_gc; zend_object *obj = (zend_object*)ref; if (EXPECTED(!(GC_FLAGS(ref) &amp; IS_OBJ_FREE_CALLED) &amp;&amp; (get_gc = obj-&gt;handlers-&gt;get_gc) != NULL)) &#123; int n; zval *zv, *end; zval tmp; ZVAL_OBJ(&amp;tmp, obj); ht = get_gc(&amp;tmp, &amp;zv, &amp;n); end = zv + n; if (EXPECTED(!ht)) &#123; if (!n) return; while (!Z_REFCOUNTED_P(--end)) &#123; if (zv == end) return; &#125; &#125; while (zv != end) &#123; if (Z_REFCOUNTED_P(zv)) &#123; ref = Z_COUNTED_P(zv); gc_scan(ref); &#125; zv++; &#125; if (EXPECTED(!ht)) &#123; ref = Z_COUNTED_P(zv); goto tail_call; &#125; &#125; else &#123; return; &#125; &#125; else if (GC_TYPE(ref) == IS_ARRAY) &#123; if ((zend_array*)ref == &amp;EG(symbol_table)) &#123; GC_REF_SET_BLACK(ref); return; &#125; else &#123; ht = (zend_array*)ref; &#125; &#125; else if (GC_TYPE(ref) == IS_REFERENCE) &#123; if (Z_REFCOUNTED(((zend_reference*)ref)-&gt;val)) &#123; ref = Z_COUNTED(((zend_reference*)ref)-&gt;val); goto tail_call; &#125; return; &#125; else &#123; return; &#125; if (!ht-&gt;nNumUsed) return; p = ht-&gt;arData; end = p + ht-&gt;nNumUsed; while (1) &#123; end--; zv = &amp;end-&gt;val; if (Z_TYPE_P(zv) == IS_INDIRECT) &#123; zv = Z_INDIRECT_P(zv); &#125; if (Z_REFCOUNTED_P(zv)) &#123; break; &#125; if (p == end) return; &#125; while (p != end) &#123; zv = &amp;p-&gt;val; if (Z_TYPE_P(zv) == IS_INDIRECT) &#123; zv = Z_INDIRECT_P(zv); &#125; if (Z_REFCOUNTED_P(zv)) &#123; ref = Z_COUNTED_P(zv); gc_scan(ref); &#125; p++; &#125; zv = &amp;p-&gt;val; if (Z_TYPE_P(zv) == IS_INDIRECT) &#123; zv = Z_INDIRECT_P(zv); &#125; ref = Z_COUNTED_P(zv); goto tail_call; &#125; &#125;&#125; 主要为三个函数： gc_mark_roots队规遍历，对object、array所有元素的refcount–并将其标记为灰色 gc_scan_roots这个函数对节点信息的链表再次进行深度优先遍历，如果发现zval的refcount大于等于1，则对该zval和其包含的zval的refcount加1操作，这个是对非垃圾的一个信息还原，然后将这些zval颜色属性去掉(设置成black)。如果发现zval的refcount等于0，则就标记成白色，这些是后面将要清理掉的垃圾。 gc_collect_roots 遍历节点信息链表,将前面一个步骤中标记为白色的节点信息放到GC_G(zval_to_free)为入口的链表中，这个链表用来存放将要释放的垃圾。 然后释放掉全部的节点信息，缓冲区被清空。分析结束后将重新收集节点信息。","tags":[]},{"title":"php闭包","date":"2018-08-25T06:50:55.000Z","path":"2018/08/25/php闭包/","text":"在看guzzle包的时候看大到了一段有意思的代码, 简化以后类似于下边: 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?php/*** */class test &#123; public $handler; public function __construct(callable $handler = null) &#123; $this-&gt;handler = $handler; &#125; public static function create(callable $handler) &#123; return new self($handler); &#125; public function __invoke($request,$options) &#123; $func = $this-&gt;handler; return $func($request, $options); &#125; public function test1() &#123; return [$this, 'exec1']; &#125; public function exec1($a,$b) &#123; echo ($a+$b); &#125;&#125;$test = new test();$obj = test::create($test-&gt;test1());$obj(1,4); php文档是这样描述闭包的 `PHP是将函数以string形式传递的。 可以使用任何内置或用户自定义函数，但除了语言结构例如：array()，echo，empty()，eval()，exit()，isset()，list()，print 或 unset()。 一个已实例化的 object 的方法被作为 array 传递，下标 0 包含该 object，下标 1 包含方法名。 在同一个类里可以访问 protected 和 private 方法。 静态类方法也可不经实例化该类的对象而传递，只要在下标 0 中包含类名而不是对象。自 PHP 5.2.3 起，也可以传递 ‘ClassName::methodName’。 除了普通的用户自定义函数外，也可传递 匿名函数 给回调参数。` 除了上边的这些可以作为callable参数的类型,还有一个是拥有__invoke()的实例化对象。 所以实例化的对象可以使用 [$obj,&#39;functionName&#39;] 当做闭包去传递。$obj = test::create($test-&gt;test1());将我们的test1方法赋值给新实例化的对象里。 魔术方法__invoke()表示: 当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。 所以我们调用$obj()函数时会调用到__invoke()里,最后调用到我们一开始注册的函数。 ps1234567891011121314151617181920212223242526272829303132333435363738394041class test &#123; public $handler; public function __construct(callable $handler = null) &#123; $this-&gt;handler = $handler; &#125; public static function create(callable $handler) &#123; return new self($handler); &#125; public function __invoke($request,$options) &#123; $func = $this-&gt;handler; return $func($request, $options); &#125; public function test1() &#123; return [$this, &apos;exec1&apos;]; &#125; public function exec1($a,$b) &#123; echo ($a+$b); &#125;&#125;$test = new test();$blj = test::create($test-&gt;test1());$blj(1,4);//测试对象是否可以作为callable类型参数$test = test::create(new test());","tags":[]},{"title":"php数组实现","date":"2018-08-20T12:00:08.000Z","path":"2018/08/20/php数组实现/","text":"要说php的数组,就不得不讲hashtable,以为php的数组是强依赖于hashtable实现的。一般 Times33的算法很简单，就是不断的乘33,下边是times33算法: Times33(hash)12345678910111213141516&lt;?phpfunction myHash($str) &#123; // hash(i) = hash(i-1) * 33 + str[i] $hash = 5381; $s = md5($str); //相比其它版本，进行了md5加密 $seed = 5; $len = 32;//加密后长度32 for ($i = 0; $i &lt; $len; $i++) &#123; // (hash &lt;&lt; 5) + hash 相当于 hash * 33 //$hash = sprintf(\"%u\", $hash * 33) + ord($s&#123;$i&#125;); //$hash = ($hash * 33 + ord($s&#123;$i&#125;)) &amp; 0x7FFFFFFF; $hash = ($hash &lt;&lt; $seed) + $hash + ord($s&#123;$i&#125;); &#125; return $hash &amp; 0x7FFFFFFF;&#125; 其中&lt;&lt; 表示左移,每次左移表示x2例如: 1234&lt;?php$num = 2;echo $num &lt;&lt; 2; 所以($hash &lt;&lt; $seed)表示 $hash * 32 ,同时加上$hash,也就表示 $hash * 33了。ord()函数返回字符串的首个字符的 ASCII 值。最后$hash &amp; 0x7FFFFFFF 表示与整形的最大值与操作(0x7FFFF111FFF二进制为1111111111111111111111111111),这个与操作会截取超过整形二进制部分,所以times33计算出来的值不会超过整形的最大值。 为什么要用hashtable实现php数组?因为散列表是根据关键建码值直接进项访问的数据结构。在key和value之间有一个映射函数,可以根据key直接索引到对应的value值,它并不会使用一般的对比操作,而是直接使用内存的起始位置和偏移位置进行寻址,所以会比正常的寻址要快。 散列表结构123456789101112131415161718192021struct _zend_array &#123; zend_refcounted_h gc; union &#123; struct &#123; ZEND_ENDIAN_LOHI_4( zend_uchar flags, zend_uchar nApplyCount, zend_uchar nIteratorsCount, zend_uchar reserve) &#125; v; uint32_t flags; &#125; u; uint32_t nTableMask; Bucket *arData; uint32_t nNumUsed; uint32_t nNumOfElements; uint32_t nTableSize; uint32_t nInternalPointer; zend_long nNextFreeElement; dtor_func_t pDestructor;&#125;; 主要字段介绍: gc 引用次数,垃圾回收时会用到。 union u 就不介绍了。 arData 存储元素的数组,内存是连续的,arData指向第一个元素。 nTableMask nTableSize的负数。 nTableSize 数组长度,为2的n此房。 nNumUsed 当前使用的Bucket数。 nNumOfElements 当前所有的Bucket数。 nNextFreeElement 下一个被使用的Bucket($a[] = ‘’) pDestructor 删除某个元素是会使用 Bucket结构12345typedef struct _Bucket &#123; zval val; zend_ulong h; /* hash value (or numeric index) */ zend_string *key; /* string key or NULL for numerics */&#125; Bucket; h hash出来的值(times33) *key 存储元素的key val 具体值,是个zval 如何实现php中实现散列表实现主要使用存储元素数组和 映射函数（也可以称作散列函数）和映射表 举个具体的栗子: 如果我们要在php代码中声明一个数组会发生什么?下边分析下php是如何实现数组的。 123456&lt;?php$arr= [ 'a' =&gt; '111', 'b' =&gt; '222', 'c' =&gt; 'ccc']; 首先肯定是初始化。 接下来将每个元素对应的值依照顺序拷贝到 Bucket里。 然后利用映射函数对求值,根据算出来的值将其对应的bucket的地址写到该值对应的映射这表里。 具体操作如下图: 当然我们这里的映射是理想映射,因为在映射的计算过程中可能存在冲突,后续会介绍映射函数,以及如何解映射函数计算后的冲突。 初始化1234567891011121314ZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)&#123; GC_REFCOUNT(ht) = 1; //设置引用次数 GC_TYPE_INFO(ht) = IS_ARRAY; //设置数据类型 ht-&gt;u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS; ht-&gt;nTableMask = HT_MIN_MASK; HT_SET_DATA_ADDR(ht, &amp;uninitialized_bucket); ht-&gt;nNumUsed = 0; ht-&gt;nNumOfElements = 0; ht-&gt;nInternalPointer = HT_INVALID_IDX; ht-&gt;nNextFreeElement = 0; ht-&gt;pDestructor = pDestructor; ht-&gt;nTableSize = zend_hash_check_size(nSize);&#125; 初始化的时候主要是对hashtable中各个成员的进行初始化设置,而且在这个时候不会给arData分配内存,只有在开始插入数据的时候才会为arData分配内存。 映射函数映射函数其实就是一次hash操作和和一次|操作.hash操作就是上边锁提到得到times33操作,|操作是计算出来的hash值与nTableSize进行计算。1nIndex = ket-&gt;h | nTableMask; 因为nTableMask是nTableSize的负数,所以计算出来的nIndex值区间应该为[-1,nTableMask]。 此处待补充 为什么会在[-1, nTableMask] 区间内。 写入数据在初始化的时候并不会对arData分配内存,只有在写入的时候才会真正分配内存 12345678910111213141516171819202122232425262728static void zend_always_inline zend_hash_real_init_ex(HashTable *ht, int packed)&#123; HT_ASSERT(GC_REFCOUNT(ht) == 1); ZEND_ASSERT(!((ht)-&gt;u.flags &amp; HASH_FLAG_INITIALIZED)); if (packed) &#123; HT_SET_DATA_ADDR(ht, pemalloc(HT_SIZE(ht), (ht)-&gt;u.flags &amp; HASH_FLAG_PERSISTENT)); (ht)-&gt;u.flags |= HASH_FLAG_INITIALIZED | HASH_FLAG_PACKED; HT_HASH_RESET_PACKED(ht); &#125; else &#123; (ht)-&gt;nTableMask = -(ht)-&gt;nTableSize; HT_SET_DATA_ADDR(ht, pemalloc(HT_SIZE(ht), (ht)-&gt;u.flags &amp; HASH_FLAG_PERSISTENT)); (ht)-&gt;u.flags |= HASH_FLAG_INITIALIZED; if (EXPECTED(ht-&gt;nTableMask == -8)) &#123; Bucket *arData = ht-&gt;arData; HT_HASH_EX(arData, -8) = -1; HT_HASH_EX(arData, -7) = -1; HT_HASH_EX(arData, -6) = -1; HT_HASH_EX(arData, -5) = -1; HT_HASH_EX(arData, -4) = -1; HT_HASH_EX(arData, -3) = -1; HT_HASH_EX(arData, -2) = -1; HT_HASH_EX(arData, -1) = -1; &#125; else &#123; HT_HASH_RESET(ht); &#125; &#125;&#125; 分配具体的内存 12#define HT_SIZE_EX(nTableSize, nTableMask) \\ (HT_DATA_SIZE((nTableSize)) + HT_HASH_SIZE((nTableMask))) 12345#define HT_HASH_SIZE(nTableMask) \\ (((size_t)(uint32_t)-(int32_t)(nTableMask)) * sizeof(uint32_t))#define HT_DATA_SIZE(nTableSize) \\ ((size_t)(nTableSize) * sizeof(Bucket)) 可以看到在分配具体分配内存的时候会分配 nTableSize(Bucket+uint32_t)大小的内存。讲道理只需要分配nTableSizeBucket大小内存就可以了,为什么会多余出来 nTableSizeuint32_t内存呢?因为nTableSizeuint32_t就是映射表所占内存大小。所以说Bucket会和映射表一次申请内存。写完成写入操作以后会将*arData 指向第一个Bucket。 具体在内存里的结果如图所示: 映射表在初始化的时候所有值都是-1,只有在被赋值时候会写入对应Bucket所在链表的偏移量。;ht-&gt;arData 指向第一个Bucket的位置,在赋值的时候会按照列表顺序,将值写入Bucket的value里,然后会根据映射函数算出值当做偏移量找到对应映射表的元素,然后将当前Bucket写入此元素。 ps nTableSize 为2的次方倍。 冲突如果nIndex = ket-&gt;h | nTableMask 算出来的值冲突了怎么办? 首先映射表的每个元素不是链表,所以导致无法存储多个元素。在php中是这样处理冲突的:首先映射表的所有元素初始化值为 -1 ,当前如果用冲突会将新算出来的值对应的Bucket覆盖原来旧的Bucket,然后将旧的Bucket迁移到新的Bucket,并将旧的Bucket的u2.next(默认为-1) 指向新Bucket。 如图 查找php再查找一个数组元素是,首先会根据其key 获取到计算后hash值’ket-&gt;h’,然后根据映射函数算出当前元素在映射表中的偏移量,利用当前位置+偏移量找到映射表的元素,再根据其内的偏量找到对应Bucket链表的首个元素位置,最后遍历该链表核对key值,找到对应的值。 具体实现函数:12345678910111213141516171819202122232425static zend_always_inline Bucket *zend_hash_find_bucket(const HashTable *ht, zend_string *key)&#123; zend_ulong h; uint32_t nIndex; uint32_t idx; Bucket *p, *arData; h = zend_string_hash_val(key); arData = ht-&gt;arData; nIndex = h | ht-&gt;nTableMask; idx = HT_HASH_EX(arData, nIndex); while (EXPECTED(idx != HT_INVALID_IDX)) &#123; p = HT_HASH_TO_BUCKET_EX(arData, idx); if (EXPECTED(p-&gt;key == key)) &#123; /* check for the same interned string */ return p; &#125; else if (EXPECTED(p-&gt;h == h) &amp;&amp; EXPECTED(p-&gt;key) &amp;&amp; EXPECTED(ZSTR_LEN(p-&gt;key) == ZSTR_LEN(key)) &amp;&amp; EXPECTED(memcmp(ZSTR_VAL(p-&gt;key), ZSTR_VAL(key), ZSTR_LEN(key)) == 0)) &#123; return p; &#125; idx = Z_NEXT(p-&gt;val); &#125; return NULL;&#125; 扩容数组的容量在初始化的时候已经确定了大小,就是nTableSize。当然映射函数也是根据 nTableMask 来计算的。所以我们扩容时候必须重新计算索引,也就是映射表里的值。具体扩容规则:首先当需要扩容时,会计算当前Bucket链表里删除元素数量占总表元素数量的比例,如果没有超过阈值则申请分配一个原来数组大小两倍的新素组,把元素复制到新数组上,然后重新建立索引。 阈值判断:1ht-&gt;nNumUsed &gt; ht-&gt;nNumOfElements + (ht-&gt;nNumOfElements &gt;&gt; 5 处理过程:12345678910111213141516171819202122232425262728static void ZEND_FASTCALL zend_hash_do_resize(HashTable *ht)&#123; IS_CONSISTENT(ht); HT_ASSERT(GC_REFCOUNT(ht) == 1); if (ht-&gt;nNumUsed &gt; ht-&gt;nNumOfElements + (ht-&gt;nNumOfElements &gt;&gt; 5)) &#123; /* additional term is there to amortize the cost of compaction */ HANDLE_BLOCK_INTERRUPTIONS(); zend_hash_rehash(ht); HANDLE_UNBLOCK_INTERRUPTIONS(); &#125; else if (ht-&gt;nTableSize &lt; HT_MAX_SIZE) &#123; /* Let's double the table size */ void *new_data, *old_data = HT_GET_DATA_ADDR(ht); uint32_t nSize = ht-&gt;nTableSize + ht-&gt;nTableSize; Bucket *old_buckets = ht-&gt;arData; HANDLE_BLOCK_INTERRUPTIONS(); new_data = pemalloc(HT_SIZE_EX(nSize, -nSize), ht-&gt;u.flags &amp; HASH_FLAG_PERSISTENT); ht-&gt;nTableSize = nSize; ht-&gt;nTableMask = -ht-&gt;nTableSize; HT_SET_DATA_ADDR(ht, new_data); memcpy(ht-&gt;arData, old_buckets, sizeof(Bucket) * ht-&gt;nNumUsed); pefree(old_data, ht-&gt;u.flags &amp; HASH_FLAG_PERSISTENT); zend_hash_rehash(ht); HANDLE_UNBLOCK_INTERRUPTIONS(); &#125; else &#123; zend_error_noreturn(E_ERROR, \"Possible integer overflow in memory allocation (%zu * %zu + %zu)\", ht-&gt;nTableSize * 2, sizeof(Bucket) + sizeof(uint32_t), sizeof(Bucket)); &#125;&#125; 在处理的过程中还会把已经删除的Bucket给删除。 具体的操作在zend_hash.c文件里。如果超过阈值,则会把已经删除Bucket移除,然后把又有后边的元素往前移动,不上空缺的Bucket,当然索引也会重建。 参考 time33 2.1 变量的内部实现","tags":[]},{"title":"php数据结构","date":"2018-08-19T12:30:34.000Z","path":"2018/08/19/php数据结构/","text":"[TOC] 变量php是如何统一实现各种变量类型的? 这和php变量类型的实现是密不可分的。一个变量主要有三个要素:变量名``变量类型``变量值,他们在php变量类型实现中主要对应 zval zend_value 和zend的各种数据类型。php中用$去声明一个变量,在声明的时候可以进行初始化,当然也可以不声明直接使用。一般来说,一个变量的定义包含两步:变量定义和变量初始化,在php中只定义不初始化是可以的。 变量结构体1234567891011121314151617181920212223// php zval结构struct _zval_struct &#123; zend_value value; 指向具体的value /* value */ union &#123; struct &#123; ZEND_ENDIAN_LOHI_4( zend_uchar type, /* active type */ zend_uchar type_flags, zend_uchar const_flags, zend_uchar reserved) /* call info for EX(This) */ &#125; v; uint32_t type_info; &#125; u1; union &#123; uint32_t var_flags; uint32_t next; /* hash collision chain */ uint32_t cache_slot; /* literal cache slot */ uint32_t lineno; /* line number (for ast nodes) */ uint32_t num_args; /* arguments number for EX(This) */ uint32_t fe_pos; /* foreach position */ uint32_t fe_iter_idx; /* foreach iterator index */ &#125; u2;&#125;; 变量类型其中type 表示当前变量的类型,例如string array int等,以下为php中全部变量类型。其中type 是一个无符号类型的char,他的定义是这样的1typedef unsigned char zend_uchar; 12345678910111213141516171819typedef union _zend_value &#123; zend_long lval; /* long value */ double dval; /* double value */ zend_refcounted *counted; zend_string *str; zend_array *arr; zend_object *obj; zend_resource *res; zend_reference *ref; zend_ast_ref *ast; zval *zv; void *ptr; zend_class_entry *ce; zend_function *func; struct &#123; uint32_t w1; uint32_t w2; &#125; ww; &#125; zend_value; 在这些类型里不存在boolean类型,因为在php7中已经将boolean拆分为true和false.直接保存在type中,也就是说boolean没有_zend_value结构,直接通过type字段就可以确定boolean的值。 从上边的结构体可以看出来 zend_long、double 类型不是指针类型,也就是说整形和浮点型正能进行深拷贝,并不能和其他说句类型一样进行 引用计数和写时复制。因为有引用计数和写时复制在变量赋值且不做修改时才能大量节省内存。 以string类型为例,它在php中的结构类型应该是这样的: _zend_string:123456struct _zend_string &#123; zend_refcounted_h gc; zend_ulong h; /* hash value */ size_t len; char val[1]; /*字符串起始地址*/&#125;; 其中gc 字段表示这个结构体被引用的次数,垃圾回收的时候会用到。 h 字符串通过Times33计算出来的hashcode len 字符串长度 val 字符串内容 我们在这里都会有疑问,为什么存储字符串内容的时候没有使用char*类型,而用了一个数组类型来存储。zend_string在申请内存的时候会会申请malloc(sizeof(zend_string)+字符串长度),且val[0]存的是字符串最后一个字符安“\\0” zend_string结构在内存中如下所示: 当时也在char val[1]的地方疑惑了很久,再往上找了很多文章,其中Nikita Popov(nikic，PHP 官方开发组成员，柏林科技大学的学生) 这样解释 1如果你对 C 语言了解的不是很深入的话，可能会觉得 val 的定义有些奇怪：这个声明只有一个元素，但是显然我们想存储的字符串长度肯定大于一个字符的长度。这里其实使用的是结构体的一个『黑』\b方法：在声明数组时只定义一个元素，但是实际创建 zend_string 时再分配足够的内存来存储整个字符串。这样我们还是可以通过 val 访问完整的字符串。 参考: Internal value representation in PHP 7 - Part 2 [译]变量在 PHP7 内部的实现（二） php内核分析——2.1 变量的内部实现","tags":[]},{"title":"php的引用","date":"2018-08-12T14:18:07.000Z","path":"2018/08/12/php的&符号/","text":"&amp;&amp;是php中的引用,他并不一种独立的数据类型,而是指向其他数据类型的数据结构,和C语言的指针类似。 具体作用为:当我们修改引用类型变量是,其修改的将作用于实际引用的变量上。 如果当我们使用&amp;符号生成一个引用变量时,首先会为&amp;操作生成一个zend_reference结构,zend_reference就是引用类型的结构体,他内嵌一个zval,然后此结构的体zval的value指向原来zval的value上。然后将原来zval的变量类型变为IS_REFERENCE,原来zval的value执行新创建zend_reference结构。索引&amp;的作用就是新生成zend_reference,然后将其指向原来的zval的value上,顺便把原来zval的变量类型变化为引用类型。 1234struct _zend_reference &#123; zend_refcondted_h gc; zval val; 指向原来的value.&#125;; 举个栗子12$a = time(); //步骤1$b = &amp;$a; //步骤2 步骤1 现在$a = time()是他们的数据结构指向为: 此时数据结构,一直指针指向是这个样子。 步骤2 也就是说PHP的引用在使用后新生成一个引用类型机构,然后将引用类型结构指向越来的value,最后将原来zval的value指向新生成的结构体,并将其变量类型变为引用类型,IS_REFERENCE。当然随之改变的还有计数。","tags":[]},{"title":"swagger","date":"2018-08-06T07:30:13.000Z","path":"2018/08/06/swagger/","text":"swagger 是什么鬼?swagger像是个接口生成、管理、mock、测试的框架。主要功能: 支持API自动生成同步的在线文档 这些文档可用于项目内部API审核 方便测试人员了解API 这些文档可作为客户产品文档的一部分进行发布 可以mock接口方便调试支持API规范生成代码，生成的客户端和服务器端骨架代码可以加速开发和测试速度##swagger-ui 一个是一个管理接口的服务,它可以根据swagger.json模拟接口返回。搭建swagger-ui 克隆swagger-ui git clone https://github.com/swagger-api/swagger-ui.git 配置nginx 服务 123456789101112131415161718192021222324252627282930313233server &#123; listen 8090; server_name www.swagger-ui.com; autoindex on; #charset koi8-r; # access_log logs/host.access.log main; root /Users/lijian/Desktop/code/web_code/swagger/swagger-ui/dist; location / &#123; index index.php index.html index.htm; try_files $uri $uri/ /index.php?$query_string; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; location ~ \\.php$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_split_path_info ^(.+\\.php)(/.+)$; fastcgi_param PATH_TRANSLATED $document_root$fastcgi_path_info; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125; &#125; 重启NGINXnginx -s reload 样子如下: swagger.jsonswagger.json,swagger-ui能够将swagger.json解析为对应的可处理的接口文档。 效果如上图所示。最终要的一点在于 http://localhost:8091/swagger.json该url为被解析的json地址。 当然如果我们需要管理不同项目的项目,可以单独配置个服务用来管理swagger.json。 swagger-phpgithub 地址: https://github.com/zircote/swagger-php 首先我们需要在项目里引入swagger-php 扩展包。 composer global require zircote/swagger-php 按照swagger文档写swagger备注:eg: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * @SWG\\Post( * path=&quot;/guestbook/appmsg&quot;, * summary=&quot;访客留言&quot;, * tags=&#123;&quot;new&quot;, &quot;guests&quot;&#125;, * description=&quot;访客留言&quot;, * operationId=&quot;appmsg&quot;, * @SWG\\Parameter( * description=&quot;msg&quot;, * format=&quot;string&quot;, * in=&quot;formData&quot;, * name=&quot;msg&quot;, * required=true, * type=&quot;string&quot;, * ), * @SWG\\Parameter( * description=&quot;email&quot;, * format=&quot;string&quot;, * in=&quot;formData&quot;, * name=&quot;email&quot;, * required=true, * type=&quot;string&quot;, * * ), * consumes=&#123;&quot;multipart/form-data&quot;, &quot;application/x-www-form-urlencoded&quot;&#125;, * produces=&#123;&quot;application/json&quot;&#125;, * @SWG\\Response( * response=&quot;200&quot;, * description=&quot;返回成功&quot;, * ), * ) * *//** * @SWG\\Get( * path=&quot;/get/feedback&quot;, * summary=&quot;留言表&quot;, * tags=&#123;&quot;getList&quot;&#125;, * descriptionId=&quot;appmsglist&quot;, * @SWG\\Parameter( * description=&quot;Id&quot;, * format=&quot;integer&quot;, * in=&quot;formData&quot;, * name=&quot;user_id&quot;, * required=&quot;true&quot;, * type=&quot;integer&quot; * ), * @SWG\\Parameter( * description=&quot;phone&quot;, * format=&quot;integer&quot;, * in=&quot;formData&quot;, * name=&quot;user_id&quot;, * required=&quot;true&quot;, * type=&quot;integer&quot; * ), * consumes=&#123;&quot;multipart/form-data&quot;, &quot;application/x-www-form-urlencode&quot;&#125;, * produces=&#123;&quot;application/json&quot;&#125;, * @SWG\\Response( * response=&quot;200&quot;, * description=&quot;返回成功&quot;, * ) * ) * */ 写完以后运行: ./vendor/zircote/swagger-php/bin/swagger app/Business/Hera/HeraMockApi.php -o ./../../swagger_json/rrc/swagger.json第一个为swagger.json的生成器,第二个为目标文件,第三个为生成文件。 然后我们在swagger-ui 引入生成的json即可。","tags":[]},{"title":"设计模式1","date":"2018-08-01T12:53:15.000Z","path":"2018/08/01/设计模式/","text":"builder 模式builder 建造者模式,又称生成器模式。 建造者模式是为了简化 使用多个建单的对象构建成一个复杂对象的 设计模式。 属于创建型模式。 代码示例 1234567891011121314151617181920publish class SmallWheel()&#123; &#125;publish class BigWheel()&#123; &#125;publish class SmallCar()&#123; publish $wheel;&#125;publish class BigCar()&#123; publish $wheel;&#125; 以上为零件。 12345678910111213141516171819publish CarBuilder()&#123; //创建小轿车 publish function getSmallCar() &#123; $smallCar = new SmallCar(); $smallCar-&gt;whell = new SmallWheel(); return $smallCar; &#125; //创建大轿车 publish function getBigCar() &#123; $bigCar = new BigCar(); $bigCar-&gt;whell = new BigWheel(); return $bigCar; &#125;&#125; 调度 12345$carBuilder = new CArBuilder();$smallCar = $carBuilder-&gt;getSmallCar();$bigCar = $carBuilder-&gt;getBigCar(); 备注: 建造者模式与工厂模式区别:工厂模式用于批量创建那哪一种类, 建造者模式更注重构建过程。 template method模板方法:定义一个抽象类或者/父类,由继承它的子类按照需求重写它的方法实现。 eg: 123456789101112publish abstract class Car()&#123; //强制子类实现 abstract public function run(); abstract public function turnOnTheLight(); //不强制 public function palyMusic() &#123; return 'hengheng hahei'; &#125;&#125; 继承 123456789101112public class SmaCar extends car &#123; public function run() &#123; return 'run'; &#125; public funtion turnOnTheLight() &#123; return 'turnOnTheLight'; &#125;&#125; 以上","tags":[{"name":"builder template method","slug":"builder-template-method","permalink":"http://yoursite.com/tags/builder-template-method/"}]},{"title":"微服务数据一致性和服务可靠性","date":"2018-07-12T13:54:30.353Z","path":"2018/07/12/微服务数据一致性和服务可靠性/","text":"存在问题 我们的保证金服务现有结构是这个样子。在 1、2、3、4、5、6 各个阶段都会存在超时和异常问题，当负载少时，我们还可以手动人工处理，但是当数据量大的时候，问题或多的令人发指，沉浸于洗数据，无法自拔。。超时存在问题：1.当1、2、3 步骤超时时，下游服务可以忽略，当做执行失败，重试。2.当在环节4、5、6超时时，对于下游服务是也是执行失败，但是还可以重试么？ 如何提高服务可靠性对于上游服务，如何保证对下游提供可靠的服务。 补偿机制 在服务间的调用失败时，可以记录失败调用，如队列，消费重试。但是前提一定是接口幂等。 但是这样并不能解决根本性问题，如果我们在调用保证金冻结服务时，失败此时我们冻结时报操作入队列，让队列异步消费，如果此时要解冻保证金，就会出现业务异常。 所以补偿机制建议使用在 不可避免的业务异常情况下使用，我们应该尽可能的优化技术方案，来保证数据一致性，最后再采用补偿机制。 两段提交协议（2pc） preOperation 执行请求，在调用微服务前，执行预操作成功则表示此次操作可行。如果commit失败该如何处理？重新preOperetion嘛？如果接口幂等是否可以重复，commit？如何保证避免重复提交？在preOperation时，返回唯一操作ID，业务逻辑每个操作对应一个操作ID，commit失败就重试，当然前提是我们的上有服务接口幂等。 即使是这样也会存在问题，如果保证金预操作成功，但是执行一直失败呢？我们必须提供回滚机制。 大量同步RPC依赖，如何保证自身服务可靠性？ 服务之间在调用的时候，会存在大量异常、超时。我该如何处理，认为这次是失败的？还是成功的？如果依赖的服务返回成功，才算成功的话，我改如何保证服务可靠性，该如何对我的下游服务提供可靠的服务。 调用依赖服务失败，如何降级处理？ 在服务调用失败的时候，我的上游出错了，我该如何降级处理，我该重试？还是直接跳过，跳过后是否会造成微服务之间数据一致性问题。如果重试是否会造成重复提交，接口是否幂等？ 是否还欠缺回滚机制？","tags":[{"name":"分布式,事务","slug":"分布式-事务","permalink":"http://yoursite.com/tags/分布式-事务/"}]},{"title":"Item2使用sz rz命令从服务下载上传文件","date":"2018-07-12T13:27:37.000Z","path":"2018/07/12/使用sz-rz命令从服务下载上传文件/","text":"背景如何从linux服务下载/上传文件 使用scp命令 使用sz命令 这里主要介绍使用sz命令下载文件 安装 安装lrzsz hobrew install llssz 在本地编写shell用于接受sz命令下载下来的文件 上传shell iterm2-send-zmodem.sh12345678910111213141516171819202122232425262728293031323334#!/bin/bash#Author: Matt Mastracci (matthew@mastracci.com)# AppleScript from http://stackoverflow.com/questions/4309087/cancel-button-on-osascript-in-a-bash-script# licensed under cc-wiki with attribution required# Remainder of script public domainosascript -e &apos;tell application &quot;iTerm2&quot; to version&apos; &gt; /dev/null 2&gt;&amp;1 &amp;&amp; NAME=iTerm2 || NAME=iTermif [[ $NAME = &quot;iTerm&quot; ]]; then FILE=`osascript -e &apos;tell application &quot;iTerm&quot; to activate&apos; -e &apos;tell application &quot;iTerm&quot; to set thefile to choose file with prompt &quot;Choose a file to send&quot;&apos; -e &quot;do shell script (\\&quot;echo \\&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\\&quot;\\&quot;)&quot;`else FILE=`osascript -e &apos;tell application &quot;iTerm2&quot; to activate&apos; -e &apos;tell application &quot;iTerm2&quot; to set thefile to choose file with prompt &quot;Choose a file to send&quot;&apos; -e &quot;do shell script (\\&quot;echo \\&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\\&quot;\\&quot;)&quot;`fiif [[ $FILE = &quot;&quot; ]]; then echo Cancelled. # Send ZModem cancel echo -e \\\\x18\\\\x18\\\\x18\\\\x18\\\\x18 sleep 1 echo echo \\# Cancelled transferelse /usr/local/bin/sz &quot;$FILE&quot; -e -b sleep 1 echo echo \\# Received $FILEfi 下载shell iterm2-recv-zmodem.sh 12345678910111213141516171819202122232425262728#!/bin/bash# Author: Matt Mastracci (matthew@mastracci.com)# AppleScript from http://stackoverflow.com/questions/4309087/cancel-button-on-osascript-in-a-bash-script# licensed under cc-wiki with attribution required # Remainder of script public domainosascript -e &apos;tell application &quot;iTerm2&quot; to version&apos; &gt; /dev/null 2&gt;&amp;1 &amp;&amp; NAME=iTerm2 || NAME=iTermif [[ $NAME = &quot;iTerm&quot; ]]; then FILE=`osascript -e &apos;tell application &quot;iTerm&quot; to activate&apos; -e &apos;tell application &quot;iTerm&quot; to set thefile to choose folder with prompt &quot;Choose a folder to place received files in&quot;&apos; -e &quot;do shell script (\\&quot;echo \\&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\\&quot;\\&quot;)&quot;`else FILE=`osascript -e &apos;tell application &quot;iTerm2&quot; to activate&apos; -e &apos;tell application &quot;iTerm2&quot; to set thefile to choose folder with prompt &quot;Choose a folder to place received files in&quot;&apos; -e &quot;do shell script (\\&quot;echo \\&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\\&quot;\\&quot;)&quot;`fiif [[ $FILE = &quot;&quot; ]]; then echo Cancelled. # Send ZModem cancel echo -e \\\\x18\\\\x18\\\\x18\\\\x18\\\\x18 sleep 1 echo echo \\# Cancelled transferelse cd &quot;$FILE&quot; /usr/local/bin/rz -E -e -b sleep 1 echo echo echo \\# Sent \\-\\&gt; $FILEfi 配置iterm2 设置Iterm2的Tirgger特性，profiles-default-editProfiles-Advanced中的Tirgger 1234567891011添加两条trigger，分别设置Regular expression，Action，Parameters，Instant如下： 1.第一条 Regular expression: rz waiting to receive.\\*\\*B0100 Action: Run Silent Coprocess Parameters: /usr/local/bin/iterm2-send-zmodem.sh Instant: checked 2.第二条 Regular expression: \\*\\*B00000000000000 Action: Run Silent Coprocess Parameters: /usr/local/bin/iterm2-recv-zmodem.sh Instant: checked 备注:注意两个文件的权限","tags":[]},{"title":"python学习笔记一","date":"2018-07-06T09:43:01.000Z","path":"2018/07/06/python学习笔记一/","text":"在php里数组分为索引数组和关联数组但是在python里这两者数组确实不同的数据类型list:data = [1,2,3,4,5]字典{data:1}","tags":[]},{"title":"solr-增删改查","date":"2018-06-21T12:21:18.000Z","path":"2018/06/21/solr-从控制页面删除数据/","text":"背景solr 版本 5.3.1 1.删除数据solr 提供多重删除数据方式, 从控制页删除数据是一种方式,主要用于人工删除少量数据eg: 执行删除操作之前: 删除操作只需在控制页Document Type 选择XML选项,然后输入一下内容提交即可。 123&lt;commit/&gt;&lt;delete&gt;&lt;query&gt;id:change.me1&lt;/query&gt;&lt;/delete&gt;&lt;commit/&gt; 具体执行,以及http请求: 最后为执行删除后的结果: 新增数据json 方式添加数据同样在solr的控制页面,选在Document Type为json。 输入: 1&#123;&quot;id&quot;:&quot;ceshi2&quot;,&quot;title&quot;:&quot;这是一个测试&quot;&#125; 可以看出来solr是已http请求的方式请求 solr server,所以我们用程序去查询solr数据是,也可json的方式去查询。当然solr支持xml等多种功能。（solr支持从数据库导入数据）具体查询规则（目前还没找到,找到后补充）: 执行结果 更新数据第一个问题:solr不支持局部更新。所有的更新操作对于solr来说都是一次数据的删除和插入,例如: 同事又说支持局部更新,但是我还没有找到相关文档,这个带求证","tags":[]},{"title":"websocket订阅火币成交记录","date":"2018-06-19T10:15:57.000Z","path":"2018/06/19/websocket订阅火币成交记录/","text":"python3单线程：文件一：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# -*- coding: utf-8 -*-#author: maxie_ljimport _threadfrom websocket import create_connectionfrom mysqlOpertion import connect_mysqlimport gzipimport timeimport json# 链接def connect(): while(1): try: print('') # 挂代理 ws = create_connection(\"wss://www.huobi.br.com/-/s/pro/ws\") #print('链接成功') return ws break except Exception as err: #print(err) #print('connect ws error,retry...') time.sleep(1)def getsubconfig(): # 统计参数 tradeStr=[ \"\"\"&#123;\"sub\": \"market.elfusdt.trade.detail\",\"id\": \"id1\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.btcusdt.trade.detail\",\"id\": \"id2\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.htusdt.trade.detail\",\"id\": \"id3\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.swftcbtc.trade.detail\",\"id\": \"id4\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.topcbtc.trade.detail\",\"id\": \"id6\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.bchusdt.trade.detail\",\"id\": \"id7\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.ethusdt.trade.detail\",\"id\": \"id8\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.etcusdt.trade.detail\",\"id\": \"id9\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.eosusdt.trade.detail\",\"id\": \"id9\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.ltcusdt.trade.detail\",\"id\": \"id9\"&#125;\"\"\" ] return tradeStr# 订阅def sub(ws,tradeStr): ws.send(tradeStr)# 获取返回def getResponse(ws,tradeStr): db = connect_mysql.connect() while 1 : try : compressData=ws.recv() except Exception : #print('链接异常') run(tradeStr,1) try : result=gzip.decompress(compressData).decode('utf-8') except: #print('丢包解析异常') continue if result[:7] == '&#123;\"ping\"': ts=result[8:21] #print('心跳包',ts) pong='&#123;\"pong\":'+ts+'&#125;' ws.send(pong) else: if result[:5] == '&#123;\"ch\"': result = json.loads(result) #print(result) #print('------------------------------------------------------') n = 0 while n &lt; len(result['tick']['data']) : connect_mysql.commit('%s' % result['ch'].split('.')[1],result['tick']['data'][n]['price'],result['tick']['data'][n]['amount'],\"'%s'\" % result[\"tick\"][\"data\"][n][\"direction\"], \"'%s'\" % result['ch'].split('.')[1],db); n += 1def subCoin(tradeStr): ws=connect() sub(ws,tradeStr) getResponse(ws,tradeStr)def run(tradeStr,test): subCoin(tradeStr)def main(): tradeStr=getsubconfig() try : tradeStr = getsubconfig() i = 0 while i &lt; len(tradeStr) : _thread.start_new_thread( run, (tradeStr[i],i) ) i += 1 except Exception as err : print(err) while 1: passif __name__ == '__main__': main() 多线程版本：文件一：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889# -*- coding: utf-8 -*-#author: maxie_ljimport _threadfrom websocket import create_connectionfrom test1 import connect_mysqlimport gzipimport timeimport json# 链接数据库def connect(): while(1): try: ws = create_connection(\"wss://www.huobi.br.com/-/s/pro/ws\") # print('链接成功') return ws break except Exception as err: print(err) #print('connect ws error,retry...') time.sleep(1)def getsubconfig(): # 统计参数 tradeStr=[ \"\"\"&#123;\"sub\": \"market.elfusdt.trade.detail\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.btcusdt.trade.detail\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.htusdt.trade.detail\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.swftcbtc.trade.detail\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.topcbtc.trade.detail\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.bchusdt.trade.detail\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.ethusdt.trade.detail\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.etcusdt.trade.detail\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.eosusdt.trade.detail\"&#125;\"\"\", \"\"\"&#123;\"sub\": \"market.ltcusdt.trade.detail\"&#125;\"\"\" ] return tradeStr# 订阅def sub(ws,tradeStr): ws.send(tradeStr)# 获取返回def getResponse(ws): db = connect_mysql.connect() while 1 : try : compressData=ws.recv() except Exception : ws=connect() subCoin(ws) print('链接异常') try : result=gzip.decompress(compressData).decode('utf-8') except: print('丢包解析异常') continue if result[:7] == '&#123;\"ping\"': ts=result[8:21] #print('心跳包',ts) pong='&#123;\"pong\":'+ts+'&#125;' ws.send(pong) else: if result[:5] == '&#123;\"ch\"': result = json.loads(result) print(result) #print('------------------------------------------------------') n = 0 while n &lt; len(result['tick']['data']) : connect_mysql.commit('%s' % result['ch'].split('.')[1],result['tick']['data'][n]['price'],result['tick']['data'][n]['amount'],\"'%s'\" % result[\"tick\"][\"data\"][n][\"direction\"], \"'%s'\" % result['ch'].split('.')[1],db); n += 1# 订阅def subCoin(ws): tradeStr=getsubconfig() i = 0 while i &lt; len(tradeStr) : sub(ws,tradeStr[i]) i += 1# 主函数def main(): ws=connect() subCoin(ws) getResponse(ws)if __name__ == '__main__': main() 1234567891011121314151617181920212223242526272829### 文件二:```pythonimport jsonimport pymysqlimport timeclass connect_mysql(): db = &apos;&apos; def connect() : db = connect_mysql.db = pymysql.connect(&quot;localhost&quot;, &quot;root&quot;, &quot;root&quot;, &quot;huobi&quot;, charset=&apos;utf8&apos; ) return db def commit(table, price, amount, action, coin_type, db) : try: cursor = db.cursor() sql = &quot;INSERT INTO %s_success_order(action,order_amount, price, coin_type)VALUES (%s, %.10f, %.10f,%s )&quot; % (table,action, amount, price,coin_type ) cursor.execute(sql) # 提交到数据库执行 db.commit() except Exception as e: db = connect_mysql.db = pymysql.connect(&quot;localhost&quot;, &quot;root&quot;, &quot;root&quot;, &quot;huobi&quot;, charset=&apos;utf8&apos; ) commit(table, price, amount, action, coin_type, db) return def connect_close() : connect_mysql.db.close() 文件二是单线程和多线程版的公用文件 shell 脚本123456789101112#!/bin/bashtotal=1avaliable=`ps -ef | grep -w huobi.py | grep -v grep | wc -l`diff=`expr $total - $avaliable`#echo $diff &gt;&gt; /home/script/diff.text#echo $total &gt;&gt; /home/script/diff.text#echo $avaliable &gt;&gt; /home/script/diff.textif [ $diff -gt 0 ];then for((i=0;i&lt;$diff;i++));do /usr/local/bin/python3 /home/script/huobi.py &gt;&gt; /home/script/huobi.out donefi crontab 配置123MAILTO=\"\"* * * * * sudo /bin/bash /home/script/huobi.sh 注意事项：在写shell脚本时，尽量用绝对路径。","tags":[{"name":"python, shell, crond","slug":"python-shell-crond","permalink":"http://yoursite.com/tags/python-shell-crond/"}]},{"title":"PHPExcel","date":"2017-10-30T02:42:03.000Z","path":"2017/10/30/PHPExecel/","text":"PHPEXcel 背景在工作中我们肯定会遇到由于后端管理系统不完善，而导致运营同学无法从管理系统获取想要的数据。亦或程序设计之初没有考虑到完善，导致一些必要的数据没有录入，希望后续补充批量导入。在这个时候我们就需要获取从数据批量导出数据或者导入数据，而无论导入还是导出数据，我们都希望是Excel格式。 根据Execel生成sql1.PHPExcel 准备：我们需要从github获取PHPExcel工具包。地址 https://github.com/PHPOffice/PHPExcel 打开PHPExcel文件夹，看下代码结构。我们需要的主要代码在Classes文件下，我们只需要引入PHPExcel.php即可。 代码实现1234567891011121314151617181920212223242526272829include './code/web_code/PHPExcel/Classes/PHPExcel.php';//引入必要的第三方依赖$inputFileType = 'Excel2007';//设置Excel的版本$inputFileName = './targe.xlsx';// 需要导入文件地址$currentsheet = $objPHPExcel-&gt;getSheet(0); //选择Excel页$maxColumn = $currentsheet-&gt;getHighestColumn(); //获取当前页的最大列数$maxRow = $currentsheet-&gt;getHighestRow(); //获取当前页的最大行数//循环拼接sqlfor ($i=2; $i&lt; $maxRow; $i++) &#123; //过滤条件 if(is_null($currentsheet-&gt;getCell('J'.$i)-&gt;getValue())||$currentsheet-&gt;getCell('J'.$i)-&gt;getValue()== '已退款' || $currentsheet-&gt;getCell('J'.$i)-&gt;getValue() == '待退款' || $currentsheet-&gt;getCell('J'.$i)-&gt;getValue() == '已经申请退款' || $currentsheet-&gt;getCell('J'.$i)-&gt;getValue() == '退了' ||$currentsheet-&gt;getCell('J'.$i)-&gt;getValue() == '没有电话' || $currentsheet-&gt;getCell('J'.$i)-&gt;getValue() == '0') &#123; continue; &#125; //过滤条件 if(!is_numeric($currentsheet-&gt;getCell('J'.$i)-&gt;getValue())||$currentsheet-&gt;getCell('J'.$i)-&gt;getValue() == '0' || empty($currentsheet-&gt;getCell('J'.$i)-&gt;getValue()) || $currentsheet-&gt;getCell('J'.$i)-&gt;getValue() == '') &#123; continue; &#125; $sql_bd_name .= ' WHEN '.$currentsheet-&gt;getCell('A'.$i)-&gt;getValue().' THEN '.$currentsheet-&gt;getCell('J'.$i)-&gt;getValue(); $sql_bd_name .= ','.$currentsheet-&gt;getCell('A'.$i)-&gt;getValue(); $res +=1;&#125;//输入，当然这里无论我们用fopen或者其他的输入当属都可以，这里我把结果打到了控制台。echo $sql_bd_name;echo $res 我们生成的sql是WHEN THEN的样式，完整语句应该是 update tablename set seller_jn_activity CASE idWHEN 1 TEHN 2END,bd_jn_activity CASE idwhen 2 THEN 3ENDWHERE in (1,2,3) 发现数据清洗其实是一件很麻烦的事。","tags":[]},{"title":"一次HTTP请求","date":"2016-11-20T12:09:23.000Z","path":"2016/11/20/一次HTTP请求/","text":"#一次完整的HTTP请求，以及请求方式的区别 今天在对接业务组mas时候遇到一个很少遇到的问题，发送一个一个不但参数的POST的请求。在我的印象里传参好像必带名字，因为就像一个你不认识的人要来你家，你肯定不会让他进来的。所以重新缕了一下POST请求，冲冲能。 ##一次HTTP请求的过程 访问某个网址，例如我们访问www.baidu.com浏览器会和百度的服务器进行三次握手（中间的域名解析等暂不考虑）然后是程序层面的信息请求与提交 三次握手-&gt;get或者post请求 1） Client首先发送一个连接试探，ACK=0 表示确认号无效，SYN = 1 表示这是一个连接请求或连接接受报文，同时表示这个数据报不能携带数据，seq = x 表示Client自己的初始序号（seq = 0 就代表这是第0号包），这时候Client进入syn_sent状态，表示客户端等待服务器的回复 2） Server监听到连接请求报文后，如同意建立连接，则向Client发送确认。TCP报文首部中的SYN 和 ACK都置1 ，ack = x + 1表示期望收到对方下一个报文段的第一个数据字节序号是x+1，同时表明x为止的所有数据都已正确收到（ack=1其实是ack=0+1,也就是期望客户端的第1个包），seq = y 表示Server 自己的初始序号（seq=0就代表这是服务器这边发出的第0号包）。这时服务器进入syn_rcvd，表示服务器已经收到Client的连接请求，等待client的确认。 3） Client收到确认后还需再次发送确认，同时携带要发送给Server的数据。ACK 置1 表示确认号ack= y + 1 有效（代表期望收到服务器的第1个包），Client自己的序号seq= x + 1（表示这就是我的第1个包，相对于第0个包来说的），一旦收到Client的确认之后，这个TCP连接就进入Established状态，就可以发起http请求了。 post请求HTTP 协议是以 ASCII 码传输，建立在TCP/IP协议之上的应用层规范，规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。类似于下面这样： 协议规定 POST 提交的数据必须放在消息主体（entity-body）中，但协议并没有规定数据必须使用什么编码方式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。 但是，数据发送出去，还要服务端解析成功才有意义。一般服务端语言如 php、python 等，以及它们的 framework，都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。所以说到 POST 提交数据方案，包含了 Content-Type 和消息主体编码方式两部分。下面就正式开始介绍它们。 headerContent-Type，内容类型，一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定文件接收方将以什么形式、什么编码读取这个文件.当然还有UA等其他头信息， Content-Type对照表：http://tool.oschina.net/commons 说几种常见的Content-Type 1.application/x-www-form-urlencoded这个就是我们常见form表格提的方式 2.multipart/form-data 这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 form 的 enctyped 等于这个值。直接来看一个请求示例 3.application/json application/json 这个 Content-Type 作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。 so 用这种格式就可以传递非Key Val的数据","tags":[]},{"title":"php curl","date":"2015-07-18T12:28:10.000Z","path":"2015/07/18/php-curl/","text":"参数1curl_setoptCURLOPT_RETURNTRANSFER 表示是否直接输出到控制台 eg: 1234567$curl = curl_init();curl_setopt($curl, CURLOPT_URL, 'http://baidu.com');curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);curl_setopt($curl, CURLOPT_HEADER, 0);// curl_setopt($curl, CURLOPT_POST, 1);$ret = curl_exec($curl);// var_dump($ret); 输出结果为: 打开参数 12345678&lt;?php$curl = curl_init();curl_setopt($curl, CURLOPT_URL, &apos;http://baidu.com&apos;);curl_setopt($curl, CURLOPT_RETURNTRANSFER, 0);curl_setopt($curl, CURLOPT_HEADER, 0);// curl_setopt($curl, CURLOPT_POST, 1);$ret = curl_exec($curl);// var_dump($ret); 输出结果 参数2CURLOPT_HEADERCURLOPT_HEADER 表示是否输出头信息 12345678&lt;?php$curl = curl_init();curl_setopt($curl, CURLOPT_URL, &apos;http://baidu.com&apos;);curl_setopt($curl, CURLOPT_RETURNTRANSFER, 0);curl_setopt($curl, CURLOPT_HEADER, 1);// curl_setopt($curl, CURLOPT_POST, 1);$ret = curl_exec($curl);// var_dump($ret); 返回结果 12345678&lt;?php$curl = curl_init();curl_setopt($curl, CURLOPT_URL, &apos;http://baidu.com&apos;);curl_setopt($curl, CURLOPT_RETURNTRANSFER, 0);curl_setopt($curl, CURLOPT_HEADER, 0);// curl_setopt($curl, CURLOPT_POST, 1);$ret = curl_exec($curl);// var_dump($ret); 返回结果 get 与 postget123456789//初始化$curl = curl_init();//设置urlcurl_setopt($curl, CURLOPT_URL, &apos;http://baidu.com&apos;);curl_setopt($curl, CURLOPT_RETURNTRANSFER, 0);curl_setopt($curl, CURLOPT_HEADER, 0);$ret = curl_exec($curl);//关闭curl_close($curl); post 12345678910//初始化$curl = curl_init();//设置urlcurl_setopt($curl, CURLOPT_URL, &apos;http://baidu.com&apos;);curl_setopt($curl, CURLOPT_RETURNTRANSFER, 0);curl_setopt($curl, CURLOPT_HEADER, 0);curl_setopt($curl, CURLOPT_POST, 1);$ret = curl_exec($curl);//关闭curl_close($curl);","tags":[{"name":"curl","slug":"curl","permalink":"http://yoursite.com/tags/curl/"}]},{"title":"github","date":"2015-06-26T14:04:09.000Z","path":"2015/06/26/github/","text":"#关于Git的使用 Git的安装和使用 准备工作： 下载git 客户端 链接地址 下载完毕后，安装一路一下一步。安装完成之后我们开始使用Git使用前我们需要告诉Git，我们是谁。所以需要配置一些信息，来确定我们的身份。 12git config –global user.name “用户名”git config –global user.email “邮箱” 第一条命令用来告诉 git 我们的名字（以后链接github）第二条命令用来告诉git 我们的邮箱 到此我们就可以使用Git了 链接github如果我们希望把自己的项目托管在github我们就需要再做一些配置 首先我们需要生成ssh,使用以下命令1ssh-keygen –t rsa –C 然后他提示的默认路径生成一些文件，或者你自己配置路径。 在生成过程中会让你输入密码，可以不输入，一路回车生成完毕后，会在你选择路径下生成两个文件 一个是 .rsa 一个是 .pub 我们这里只需要.pub里的内容 复制里边的内容 接下来我们需要把文件里的key添加到我们的github账号里。 首先我们登陆我们的github账号。 然后在设置里 NEW SSH KEY 添加描述然后把我们的key复制到里边即可。 不过在提交之前我们还需要做一些配置来确定我们需要把当前库的代码推送到github账号的哪个库里1git remote add origin git@github.com:aaa/xxx 在上边的配置的命令中，aaa表示的我们的github账号。xxx使我们的库文件。以后就可以使用git来进行版本管理和推送到github里了。正常操作代码1234git statusgit add .git commit -a &apos;message&apos;git push 提交完毕。 如果我们需要在其他电脑上使用我们托管的代码，我们需要使用1git pull 或者1git colne &apos;address&apos; 来从github上获取我们所需要的代码 如果在配置过程中出现错误，按照提示的代码解决即可。当然在此如果我们直接使用了1git commit -a 会弹出来vim窗口，在这里写一些vim的命令在非insert状态下我们使用ctrl+d来批量选择#，然后按d删除 在飞插入模式写:wq 保存并推出","tags":[]},{"title":"hexo git github搭建博客","date":"2015-06-02T13:48:07.000Z","path":"2015/06/02/hexo-git-github搭建博客/","text":"开始**需求环境 git git下载地址 node.js node.js下载地址 两个安装都是一路下一步 验证软件正确安装git --version node -v npm -v 如果显示版本信息，怎安装成功。 安装hexo在这里如果被墙的可以使用淘宝镜像cnpm 具体怎么操作可以自行百度，这里不多做解释。不过一般不会被墙，我使用npm。运行下边的命令安装hexo：被墙请使用命令： npm install -g cnpm --registry=https://registry.npm.taobao.org 以下是没有被墙的命令，被墙把npm换成cnpm即可。安装hexo npm install hexo-cli -g 安装完成后，验证是否安装成功。 hexo -v 新建文件夹yourblog,输入命令 $ hexo init blog $ cd blog 新建博客 $ hexo new &quot;Hello Hexo&quot; 生成静态页面 $ hexo generate 运行服务 $ hexo server 然后打开浏览器输入 localhost:4000 即可访问本地静态页面。 接下来我们把本地静态页面PUSH到github 首先你要有github账号。 新建一个github.io的库 设置本地github配置参数 经本地静态页面push到github github设置 新建github账号就不在这里陈述了，如果有同学不会使用git将代码push到github的话可以参考 廖雪峰的官网我们来直接进行第二不，创建一个github.io库。首先登陆我们的github账号点击new repository,然后输入youname.github.iogit设置设置git配置信息 $ git config --global user.name &quot;你的用户名&quot; $ git config --global user.email &quot;你的邮箱&quot; hexo 设置 安装hexo git插件 npm install hexo-deployer-git --save 然后打开博客根目录的_config.yml文件大致内容是这个样子的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: 和女票抢可乐subtitle:description:author: MaxieLjlanguage:timezone:# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://yoursite.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: yilia# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/MaxieLj/MaxieLj.github.io.git branch: masterjsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 我们只需要在尾部添加：1234deploy: type: git repository: https://github.com/MaxieLj/MaxieLj.github.io.git branch: master 然后我们运行 $ hexo g 生成静态文件然后推送到github $ hexo d 然后访问youname.github.io就可以看到生成的静态页面了当然我们一般是在本地调试好再用 hexo d推送到github","tags":[]}]