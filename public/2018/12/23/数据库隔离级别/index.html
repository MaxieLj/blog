<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 数据库隔离级别 · Maxie'blog</title><meta name="description" content="数据库隔离级别 - MaxieLj"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Maxie'blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/MaxieLj" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">数据库隔离级别</h1><div class="post-info">Dec 23, 2018</div><div class="post-content"><p>SQL标准规范中定义了四种数据库隔离级别。每种隔离级别带来的系统开销是不一样的。通常较低的隔离级别的系统开销会更低，可以执行更高的并发。</p>
<h2 id="READ-COMMITTED-未提交读"><a href="#READ-COMMITTED-未提交读" class="headerlink" title="READ COMMITTED(未提交读)"></a>READ COMMITTED(未提交读)</h2><p>顾名思义，未提交读隔离级别中，事物的修改即使没有提交，对其他事务也是可见的。事务可以读取为未提交的数据，也成为<code>脏读</code>。READ COMMITED 性能上不会有跟很大的优势，但是却会导致很多的问题，在实际应用中很少使用。</p>
<p>eg:<br>业务场景支付扣款。当用户统一时刻发生一笔充值500，和一笔扣款200业务时。 扣款读到是未执行的充值事务金额，账户余额500元，但是充值事务回滚了，这种情况下数据出现问题，所以未提交读是一种不可靠的事务。</p>
<h2 id="READ-COMMITED-提交读"><a href="#READ-COMMITED-提交读" class="headerlink" title="READ COMMITED(提交读)"></a>READ COMMITED(提交读)</h2><p>多数数据库的隔离级是提交读(比如Sql Server , Oracle)，但是mysql不是。<br>提交读的含义是：一个事务只能看到已经提交的事务所做的修改。也就是说事务和事务之前在提交前是相互不可见的。这个级别又称为不可重复读，因为每次读取的结果可能是不一样的。</p>
<p>eg:<br>当我们拿着银行卡去消费时候，查询到卡里还有2000元，这时准备消费。与此同时这张卡的钱被老婆转账了（已经转出去2000元），当我们在扣款你的时候会提示余额不足。<br>提交读避免了<code>脏读</code>，但是却产生了<code>不可重复读</code>（同一事务内）。</p>
<h2 id="Repeatable-read-（重复读）"><a href="#Repeatable-read-（重复读）" class="headerlink" title="Repeatable read （重复读）"></a>Repeatable read （重复读）</h2><p>重复读，保证了在同一个事务内读取同一条数据是不变的，但是却无法保证我们读取（同一事务内）同一表里的数据量是一致的。但是却会产生幻读（幻行）。</p>
<p>例如消费记录表，我们在打印信用卡的消费记录时查询出来只有一条消费记录80（这是另外一个事务无法改变的），但是在我们打印的时候，老婆又消费了1000元（另外一个事务，但是没有对原来的80元进行修改），我们打印出来的结果是两条记录 80 +1000，这就是幻行。</p>
<h2 id="Serializable-（序列化）"><a href="#Serializable-（序列化）" class="headerlink" title="Serializable （序列化）"></a>Serializable （序列化）</h2><p>Serializable 通过强制事务串行执行避免了欢读。但是Serializable在执行的时候会对每一样的数据都加上锁，会导致大量的超时和锁竞争。只有在数据一致性非常重要，且并发不是很大情况选，可以选用这种隔离级别。</p>
<h2 id="几个名词"><a href="#几个名词" class="headerlink" title="几个名词"></a>几个名词</h2><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>指的是在A事务内，多次读取同一一个数据。与此同时还有另外一个B事务对同一数据进行了修改，但是未提交。这时就会产生事务A两次读取的数据不一致，一个是事务B未执行前的数据，一个是读取事务B未提交的数据。</p>
<h3 id="不可重复读。"><a href="#不可重复读。" class="headerlink" title="不可重复读。"></a>不可重复读。</h3><p>指的是同一事务内，无法对同一个数据多次读取，因为两次读取可能是不一致的（因为没有对 数据写 加锁）。</p>
<h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>幻读是在<code>可重复读</code>的隔离级别下产生的问题。<code>可重复读</code>虽然对数据加写锁，但是却没对表加锁，造成每次读取表的数据量是不一致的，所以又称<code>幻行</code>。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/12/02/kong/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">MaxieLj</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>